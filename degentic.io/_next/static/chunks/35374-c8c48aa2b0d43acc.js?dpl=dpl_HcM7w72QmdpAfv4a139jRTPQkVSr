(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
    [35374], {
        863: (t, e, i) => {
            let n = i(56880).getSymbolSize;
            e.getRowColCoords = function(t) {
                if (1 === t) return [];
                let e = Math.floor(t / 7) + 2,
                    i = n(t),
                    r = 145 === i ? 26 : 2 * Math.ceil((i - 13) / (2 * e - 2)),
                    s = [i - 7];
                for (let t = 1; t < e - 1; t++) s[t] = s[t - 1] - r;
                return s.push(6), s.reverse()
            }, e.getPositions = function(t) {
                let i = [],
                    n = e.getRowColCoords(t),
                    r = n.length;
                for (let t = 0; t < r; t++)
                    for (let e = 0; e < r; e++)(0 !== t || 0 !== e) && (0 !== t || e !== r - 1) && (t !== r - 1 || 0 !== e) && i.push([n[t], n[e]]);
                return i
            }
        },
        3455: (t, e) => {
            let i = new Uint8Array(512),
                n = new Uint8Array(256);
            ! function() {
                let t = 1;
                for (let e = 0; e < 255; e++) i[e] = t, n[t] = e, 256 & (t <<= 1) && (t ^= 285);
                for (let t = 255; t < 512; t++) i[t] = i[t - 255]
            }(), e.log = function(t) {
                if (t < 1) throw Error("log(" + t + ")");
                return n[t]
            }, e.exp = function(t) {
                return i[t]
            }, e.mul = function(t, e) {
                return 0 === t || 0 === e ? 0 : i[n[t] + n[e]]
            }
        },
        13478: (t, e, i) => {
            "use strict";
            let n;

            function r(t) {
                return null !== t && "object" == typeof t && "function" == typeof t.start
            }

            function s(t) {
                let e = [{}, {}];
                return null == t || t.values.forEach((t, i) => {
                    e[0][i] = t.get(), e[1][i] = t.getVelocity()
                }), e
            }

            function o(t, e, i, n) {
                if ("function" == typeof e) {
                    let [r, o] = s(n);
                    e = e(void 0 !== i ? i : t.custom, r, o)
                }
                if ("string" == typeof e && (e = t.variants && t.variants[e]), "function" == typeof e) {
                    let [r, o] = s(n);
                    e = e(void 0 !== i ? i : t.custom, r, o)
                }
                return e
            }

            function a(t, e, i) {
                let n = t.getProps();
                return o(n, e, void 0 !== i ? i : n.custom, t)
            }

            function l(t) {
                let e;
                return () => (void 0 === e && (e = t()), e)
            }
            i.d(e, {
                P: () => sy
            });
            let u = l(() => void 0 !== window.ScrollTimeline);
            class h {
                constructor(t) {
                    this.stop = () => this.runAll("stop"), this.animations = t.filter(Boolean)
                }
                get finished() {
                    return Promise.all(this.animations.map(t => "finished" in t ? t.finished : t))
                }
                getAll(t) {
                    return this.animations[0][t]
                }
                setAll(t, e) {
                    for (let i = 0; i < this.animations.length; i++) this.animations[i][t] = e
                }
                attachTimeline(t, e) {
                    let i = this.animations.map(i => u() && i.attachTimeline ? i.attachTimeline(t) : "function" == typeof e ? e(i) : void 0);
                    return () => {
                        i.forEach((t, e) => {
                            t && t(), this.animations[e].stop()
                        })
                    }
                }
                get time() {
                    return this.getAll("time")
                }
                set time(t) {
                    this.setAll("time", t)
                }
                get speed() {
                    return this.getAll("speed")
                }
                set speed(t) {
                    this.setAll("speed", t)
                }
                get startTime() {
                    return this.getAll("startTime")
                }
                get duration() {
                    let t = 0;
                    for (let e = 0; e < this.animations.length; e++) t = Math.max(t, this.animations[e].duration);
                    return t
                }
                runAll(t) {
                    this.animations.forEach(e => e[t]())
                }
                flatten() {
                    this.runAll("flatten")
                }
                play() {
                    this.runAll("play")
                }
                pause() {
                    this.runAll("pause")
                }
                cancel() {
                    this.runAll("cancel")
                }
                complete() {
                    this.runAll("complete")
                }
            }
            class d extends h {
                then(t, e) {
                    return Promise.all(this.animations).then(t).catch(e)
                }
            }

            function c(t, e) {
                return t ? t[e] || t.default || t : void 0
            }

            function p(t) {
                let e = 0,
                    i = t.next(e);
                for (; !i.done && e < 2e4;) e += 50, i = t.next(e);
                return e >= 2e4 ? 1 / 0 : e
            }

            function f(t) {
                return "function" == typeof t
            }

            function m(t, e) {
                t.timeline = e, t.onfinish = null
            }
            let g = t => Array.isArray(t) && "number" == typeof t[0],
                v = {
                    linearEasing: void 0
                },
                y = function(t, e) {
                    let i = l(t);
                    return () => {
                        var t;
                        return null !== (t = v[e]) && void 0 !== t ? t : i()
                    }
                }(() => {
                    try {
                        document.createElement("div").animate({
                            opacity: 0
                        }, {
                            easing: "linear(0, 1)"
                        })
                    } catch (t) {
                        return !1
                    }
                    return !0
                }, "linearEasing"),
                x = (t, e, i) => {
                    let n = e - t;
                    return 0 === n ? 1 : (i - t) / n
                },
                w = (t, e, i = 10) => {
                    let n = "",
                        r = Math.max(Math.round(e / i), 2);
                    for (let e = 0; e < r; e++) n += t(x(0, r - 1, e)) + ", ";
                    return `linear(${n.substring(0,n.length-2)})`
                },
                T = ([t, e, i, n]) => `cubic-bezier(${t}, ${e}, ${i}, ${n})`,
                P = {
                    linear: "linear",
                    ease: "ease",
                    easeIn: "ease-in",
                    easeOut: "ease-out",
                    easeInOut: "ease-in-out",
                    circIn: T([0, .65, .55, 1]),
                    circOut: T([.55, 0, 1, .45]),
                    backIn: T([.31, .01, .66, -.59]),
                    backOut: T([.33, 1.53, .69, .99])
                },
                b = {
                    x: !1,
                    y: !1
                };

            function E(t, e) {
                let i = function(t, e, i) {
                        var n;
                        if (t instanceof EventTarget) return [t];
                        if ("string" == typeof t) {
                            let e = document,
                                i = (n = void 0, e.querySelectorAll(t));
                            return i ? Array.from(i) : []
                        }
                        return Array.from(t)
                    }(t),
                    n = new AbortController;
                return [i, {
                    passive: !0,
                    ...e,
                    signal: n.signal
                }, () => n.abort()]
            }

            function A(t) {
                return !("touch" === t.pointerType || b.x || b.y)
            }

            function S(t, e) {
                let i = `${e}PointerCapture`;
                if (t.target instanceof Element && i in t.target && void 0 !== t.pointerId) try {
                    t.target[i](t.pointerId)
                } catch (t) {}
            }
            let C = (t, e) => !!e && (t === e || C(t, e.parentElement)),
                M = t => "mouse" === t.pointerType ? "number" != typeof t.button || t.button <= 0 : !1 !== t.isPrimary,
                R = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]),
                V = new WeakSet;

            function k(t) {
                return e => {
                    "Enter" === e.key && t(e)
                }
            }

            function D(t, e) {
                t.dispatchEvent(new PointerEvent("pointer" + e, {
                    isPrimary: !0,
                    bubbles: !0
                }))
            }
            let L = (t, e) => {
                let i = t.currentTarget;
                if (!i) return;
                let n = k(() => {
                    if (V.has(i)) return;
                    D(i, "down");
                    let t = k(() => {
                        D(i, "up")
                    });
                    i.addEventListener("keyup", t, e), i.addEventListener("blur", () => D(i, "cancel"), e)
                });
                i.addEventListener("keydown", n, e), i.addEventListener("blur", () => i.removeEventListener("keydown", n), e)
            };

            function B(t) {
                return M(t) && !(b.x || b.y)
            }
            let j = t => 1e3 * t,
                I = t => t / 1e3,
                F = t => t,
                N = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"],
                O = new Set(N),
                U = new Set(["width", "height", "top", "left", "right", "bottom", ...N]),
                $ = t => Array.isArray(t),
                H = t => !!(t && "object" == typeof t && t.mix && t.toValue),
                z = t => $(t) ? t[t.length - 1] || 0 : t,
                Y = {
                    skipAnimations: !1,
                    useManualTiming: !1
                },
                W = ["read", "resolveKeyframes", "update", "preRender", "render", "postRender"],
                K = {
                    value: null,
                    addProjectionMetrics: null
                };

            function _(t, e) {
                let i = !1,
                    n = !0,
                    r = {
                        delta: 0,
                        timestamp: 0,
                        isProcessing: !1
                    },
                    s = () => i = !0,
                    o = W.reduce((t, i) => (t[i] = function(t, e) {
                        let i = new Set,
                            n = new Set,
                            r = !1,
                            s = !1,
                            o = new WeakSet,
                            a = {
                                delta: 0,
                                timestamp: 0,
                                isProcessing: !1
                            },
                            l = 0;

                        function u(e) {
                            o.has(e) && (h.schedule(e), t()), l++, e(a)
                        }
                        let h = {
                            schedule: (t, e = !1, s = !1) => {
                                let a = s && r ? i : n;
                                return e && o.add(t), a.has(t) || a.add(t), t
                            },
                            cancel: t => {
                                n.delete(t), o.delete(t)
                            },
                            process: t => {
                                if (a = t, r) {
                                    s = !0;
                                    return
                                }
                                r = !0, [i, n] = [n, i], i.forEach(u), e && K.value && K.value.frameloop[e].push(l), l = 0, i.clear(), r = !1, s && (s = !1, h.process(t))
                            }
                        };
                        return h
                    }(s, e ? i : void 0), t), {}),
                    {
                        read: a,
                        resolveKeyframes: l,
                        update: u,
                        preRender: h,
                        render: d,
                        postRender: c
                    } = o,
                    p = () => {
                        let s = Y.useManualTiming ? r.timestamp : performance.now();
                        i = !1, Y.useManualTiming || (r.delta = n ? 1e3 / 60 : Math.max(Math.min(s - r.timestamp, 40), 1)), r.timestamp = s, r.isProcessing = !0, a.process(r), l.process(r), u.process(r), h.process(r), d.process(r), c.process(r), r.isProcessing = !1, i && e && (n = !1, t(p))
                    },
                    f = () => {
                        i = !0, n = !0, r.isProcessing || t(p)
                    };
                return {
                    schedule: W.reduce((t, e) => {
                        let n = o[e];
                        return t[e] = (t, e = !1, r = !1) => (i || f(), n.schedule(t, e, r)), t
                    }, {}),
                    cancel: t => {
                        for (let e = 0; e < W.length; e++) o[W[e]].cancel(t)
                    },
                    state: r,
                    steps: o
                }
            }
            let {
                schedule: X,
                cancel: q,
                state: J,
                steps: Q
            } = _("undefined" != typeof requestAnimationFrame ? requestAnimationFrame : F, !0);

            function G() {
                n = void 0
            }
            let Z = {
                now: () => (void 0 === n && Z.set(J.isProcessing || Y.useManualTiming ? J.timestamp : performance.now()), n),
                set: t => {
                    n = t, queueMicrotask(G)
                }
            };

            function tt(t, e) {
                -1 === t.indexOf(e) && t.push(e)
            }

            function te(t, e) {
                let i = t.indexOf(e);
                i > -1 && t.splice(i, 1)
            }
            class ti {
                constructor() {
                    this.subscriptions = []
                }
                add(t) {
                    return tt(this.subscriptions, t), () => te(this.subscriptions, t)
                }
                notify(t, e, i) {
                    let n = this.subscriptions.length;
                    if (n) {
                        if (1 === n) this.subscriptions[0](t, e, i);
                        else
                            for (let r = 0; r < n; r++) {
                                let n = this.subscriptions[r];
                                n && n(t, e, i)
                            }
                    }
                }
                getSize() {
                    return this.subscriptions.length
                }
                clear() {
                    this.subscriptions.length = 0
                }
            }
            let tn = t => !isNaN(parseFloat(t)),
                tr = {
                    current: void 0
                };
            class ts {
                constructor(t, e = {}) {
                    this.version = "12.4.10", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (t, e = !0) => {
                        let i = Z.now();
                        this.updatedAt !== i && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(t), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), e && this.events.renderRequest && this.events.renderRequest.notify(this.current)
                    }, this.hasAnimated = !1, this.setCurrent(t), this.owner = e.owner
                }
                setCurrent(t) {
                    this.current = t, this.updatedAt = Z.now(), null === this.canTrackVelocity && void 0 !== t && (this.canTrackVelocity = tn(this.current))
                }
                setPrevFrameValue(t = this.current) {
                    this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt
                }
                onChange(t) {
                    return this.on("change", t)
                }
                on(t, e) {
                    this.events[t] || (this.events[t] = new ti);
                    let i = this.events[t].add(e);
                    return "change" === t ? () => {
                        i(), X.read(() => {
                            this.events.change.getSize() || this.stop()
                        })
                    } : i
                }
                clearListeners() {
                    for (let t in this.events) this.events[t].clear()
                }
                attach(t, e) {
                    this.passiveEffect = t, this.stopPassiveEffect = e
                }
                set(t, e = !0) {
                    e && this.passiveEffect ? this.passiveEffect(t, this.updateAndNotify) : this.updateAndNotify(t, e)
                }
                setWithVelocity(t, e, i) {
                    this.set(e), this.prev = void 0, this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt - i
                }
                jump(t, e = !0) {
                    this.updateAndNotify(t), this.prev = t, this.prevUpdatedAt = this.prevFrameValue = void 0, e && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect()
                }
                get() {
                    return tr.current && tr.current.push(this), this.current
                }
                getPrevious() {
                    return this.prev
                }
                getVelocity() {
                    var t;
                    let e = Z.now();
                    if (!this.canTrackVelocity || void 0 === this.prevFrameValue || e - this.updatedAt > 30) return 0;
                    let i = Math.min(this.updatedAt - this.prevUpdatedAt, 30);
                    return t = parseFloat(this.current) - parseFloat(this.prevFrameValue), i ? 1e3 / i * t : 0
                }
                start(t) {
                    return this.stop(), new Promise(e => {
                        this.hasAnimated = !0, this.animation = t(e), this.events.animationStart && this.events.animationStart.notify()
                    }).then(() => {
                        this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation()
                    })
                }
                stop() {
                    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation()
                }
                isAnimating() {
                    return !!this.animation
                }
                clearAnimation() {
                    delete this.animation
                }
                destroy() {
                    this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect()
                }
            }

            function to(t, e) {
                return new ts(t, e)
            }
            let ta = t => !!(t && t.getVelocity);

            function tl(t, e) {
                let i = t.getValue("willChange");
                if (ta(i) && i.add) return i.add(e)
            }
            let tu = t => t.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(),
                th = "data-" + tu("framerAppearId"),
                td = {
                    current: !1
                },
                tc = (t, e, i) => (((1 - 3 * i + 3 * e) * t + (3 * i - 6 * e)) * t + 3 * e) * t;

            function tp(t, e, i, n) {
                if (t === e && i === n) return F;
                let r = e => (function(t, e, i, n, r) {
                    let s, o;
                    let a = 0;
                    do(s = tc(o = e + (i - e) / 2, n, r) - t) > 0 ? i = o : e = o; while (Math.abs(s) > 1e-7 && ++a < 12);
                    return o
                })(e, 0, 1, t, i);
                return t => 0 === t || 1 === t ? t : tc(r(t), e, n)
            }
            let tf = t => e => e <= .5 ? t(2 * e) / 2 : (2 - t(2 * (1 - e))) / 2,
                tm = t => e => 1 - t(1 - e),
                tg = tp(.33, 1.53, .69, .99),
                tv = tm(tg),
                ty = tf(tv),
                tx = t => (t *= 2) < 1 ? .5 * tv(t) : .5 * (2 - Math.pow(2, -10 * (t - 1))),
                tw = t => 1 - Math.sin(Math.acos(t)),
                tT = tm(tw),
                tP = tf(tw),
                tb = t => /^0[^.\s]+$/u.test(t),
                tE = (t, e, i) => i > e ? e : i < t ? t : i,
                tA = {
                    test: t => "number" == typeof t,
                    parse: parseFloat,
                    transform: t => t
                },
                tS = {
                    ...tA,
                    transform: t => tE(0, 1, t)
                },
                tC = {
                    ...tA,
                    default: 1
                },
                tM = t => Math.round(1e5 * t) / 1e5,
                tR = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu,
                tV = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,
                tk = (t, e) => i => !!("string" == typeof i && tV.test(i) && i.startsWith(t) || e && null != i && Object.prototype.hasOwnProperty.call(i, e)),
                tD = (t, e, i) => n => {
                    if ("string" != typeof n) return n;
                    let [r, s, o, a] = n.match(tR);
                    return {
                        [t]: parseFloat(r),
                        [e]: parseFloat(s),
                        [i]: parseFloat(o),
                        alpha: void 0 !== a ? parseFloat(a) : 1
                    }
                },
                tL = t => tE(0, 255, t),
                tB = {
                    ...tA,
                    transform: t => Math.round(tL(t))
                },
                tj = {
                    test: tk("rgb", "red"),
                    parse: tD("red", "green", "blue"),
                    transform: ({
                        red: t,
                        green: e,
                        blue: i,
                        alpha: n = 1
                    }) => "rgba(" + tB.transform(t) + ", " + tB.transform(e) + ", " + tB.transform(i) + ", " + tM(tS.transform(n)) + ")"
                },
                tI = {
                    test: tk("#"),
                    parse: function(t) {
                        let e = "",
                            i = "",
                            n = "",
                            r = "";
                        return t.length > 5 ? (e = t.substring(1, 3), i = t.substring(3, 5), n = t.substring(5, 7), r = t.substring(7, 9)) : (e = t.substring(1, 2), i = t.substring(2, 3), n = t.substring(3, 4), r = t.substring(4, 5), e += e, i += i, n += n, r += r), {
                            red: parseInt(e, 16),
                            green: parseInt(i, 16),
                            blue: parseInt(n, 16),
                            alpha: r ? parseInt(r, 16) / 255 : 1
                        }
                    },
                    transform: tj.transform
                },
                tF = t => ({
                    test: e => "string" == typeof e && e.endsWith(t) && 1 === e.split(" ").length,
                    parse: parseFloat,
                    transform: e => `${e}${t}`
                }),
                tN = tF("deg"),
                tO = tF("%"),
                tU = tF("px"),
                t$ = tF("vh"),
                tH = tF("vw"),
                tz = {
                    ...tO,
                    parse: t => tO.parse(t) / 100,
                    transform: t => tO.transform(100 * t)
                },
                tY = {
                    test: tk("hsl", "hue"),
                    parse: tD("hue", "saturation", "lightness"),
                    transform: ({
                        hue: t,
                        saturation: e,
                        lightness: i,
                        alpha: n = 1
                    }) => "hsla(" + Math.round(t) + ", " + tO.transform(tM(e)) + ", " + tO.transform(tM(i)) + ", " + tM(tS.transform(n)) + ")"
                },
                tW = {
                    test: t => tj.test(t) || tI.test(t) || tY.test(t),
                    parse: t => tj.test(t) ? tj.parse(t) : tY.test(t) ? tY.parse(t) : tI.parse(t),
                    transform: t => "string" == typeof t ? t : t.hasOwnProperty("red") ? tj.transform(t) : tY.transform(t)
                },
                tK = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu,
                t_ = "number",
                tX = "color",
                tq = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;

            function tJ(t) {
                let e = t.toString(),
                    i = [],
                    n = {
                        color: [],
                        number: [],
                        var: []
                    },
                    r = [],
                    s = 0,
                    o = e.replace(tq, t => (tW.test(t) ? (n.color.push(s), r.push(tX), i.push(tW.parse(t))) : t.startsWith("var(") ? (n.var.push(s), r.push("var"), i.push(t)) : (n.number.push(s), r.push(t_), i.push(parseFloat(t))), ++s, "${}")).split("${}");
                return {
                    values: i,
                    split: o,
                    indexes: n,
                    types: r
                }
            }

            function tQ(t) {
                return tJ(t).values
            }

            function tG(t) {
                let {
                    split: e,
                    types: i
                } = tJ(t), n = e.length;
                return t => {
                    let r = "";
                    for (let s = 0; s < n; s++)
                        if (r += e[s], void 0 !== t[s]) {
                            let e = i[s];
                            e === t_ ? r += tM(t[s]) : e === tX ? r += tW.transform(t[s]) : r += t[s]
                        } return r
                }
            }
            let tZ = t => "number" == typeof t ? 0 : t,
                t0 = {
                    test: function(t) {
                        var e, i;
                        return isNaN(t) && "string" == typeof t && ((null === (e = t.match(tR)) || void 0 === e ? void 0 : e.length) || 0) + ((null === (i = t.match(tK)) || void 0 === i ? void 0 : i.length) || 0) > 0
                    },
                    parse: tQ,
                    createTransformer: tG,
                    getAnimatableNone: function(t) {
                        let e = tQ(t);
                        return tG(t)(e.map(tZ))
                    }
                },
                t1 = new Set(["brightness", "contrast", "saturate", "opacity"]);

            function t2(t) {
                let [e, i] = t.slice(0, -1).split("(");
                if ("drop-shadow" === e) return t;
                let [n] = i.match(tR) || [];
                if (!n) return t;
                let r = i.replace(n, ""),
                    s = +!!t1.has(e);
                return n !== i && (s *= 100), e + "(" + s + r + ")"
            }
            let t5 = /\b([a-z-]*)\(.*?\)/gu,
                t3 = {
                    ...t0,
                    getAnimatableNone: t => {
                        let e = t.match(t5);
                        return e ? e.map(t2).join(" ") : t
                    }
                },
                t4 = {
                    ...tA,
                    transform: Math.round
                },
                t8 = {
                    borderWidth: tU,
                    borderTopWidth: tU,
                    borderRightWidth: tU,
                    borderBottomWidth: tU,
                    borderLeftWidth: tU,
                    borderRadius: tU,
                    radius: tU,
                    borderTopLeftRadius: tU,
                    borderTopRightRadius: tU,
                    borderBottomRightRadius: tU,
                    borderBottomLeftRadius: tU,
                    width: tU,
                    maxWidth: tU,
                    height: tU,
                    maxHeight: tU,
                    top: tU,
                    right: tU,
                    bottom: tU,
                    left: tU,
                    padding: tU,
                    paddingTop: tU,
                    paddingRight: tU,
                    paddingBottom: tU,
                    paddingLeft: tU,
                    margin: tU,
                    marginTop: tU,
                    marginRight: tU,
                    marginBottom: tU,
                    marginLeft: tU,
                    backgroundPositionX: tU,
                    backgroundPositionY: tU,
                    rotate: tN,
                    rotateX: tN,
                    rotateY: tN,
                    rotateZ: tN,
                    scale: tC,
                    scaleX: tC,
                    scaleY: tC,
                    scaleZ: tC,
                    skew: tN,
                    skewX: tN,
                    skewY: tN,
                    distance: tU,
                    translateX: tU,
                    translateY: tU,
                    translateZ: tU,
                    x: tU,
                    y: tU,
                    z: tU,
                    perspective: tU,
                    transformPerspective: tU,
                    opacity: tS,
                    originX: tz,
                    originY: tz,
                    originZ: tU,
                    zIndex: t4,
                    size: tU,
                    fillOpacity: tS,
                    strokeOpacity: tS,
                    numOctaves: t4
                },
                t6 = {
                    ...t8,
                    color: tW,
                    backgroundColor: tW,
                    outlineColor: tW,
                    fill: tW,
                    stroke: tW,
                    borderColor: tW,
                    borderTopColor: tW,
                    borderRightColor: tW,
                    borderBottomColor: tW,
                    borderLeftColor: tW,
                    filter: t3,
                    WebkitFilter: t3
                },
                t7 = t => t6[t];

            function t9(t, e) {
                let i = t7(t);
                return i !== t3 && (i = t0), i.getAnimatableNone ? i.getAnimatableNone(e) : void 0
            }
            let et = new Set(["auto", "none", "0"]),
                ee = t => t === tA || t === tU,
                ei = (t, e) => parseFloat(t.split(", ")[e]),
                en = (t, e) => (i, {
                    transform: n
                }) => {
                    if ("none" === n || !n) return 0;
                    let r = n.match(/^matrix3d\((.+)\)$/u);
                    if (r) return ei(r[1], e);
                    {
                        let e = n.match(/^matrix\((.+)\)$/u);
                        return e ? ei(e[1], t) : 0
                    }
                },
                er = new Set(["x", "y", "z"]),
                es = N.filter(t => !er.has(t)),
                eo = {
                    width: ({
                        x: t
                    }, {
                        paddingLeft: e = "0",
                        paddingRight: i = "0"
                    }) => t.max - t.min - parseFloat(e) - parseFloat(i),
                    height: ({
                        y: t
                    }, {
                        paddingTop: e = "0",
                        paddingBottom: i = "0"
                    }) => t.max - t.min - parseFloat(e) - parseFloat(i),
                    top: (t, {
                        top: e
                    }) => parseFloat(e),
                    left: (t, {
                        left: e
                    }) => parseFloat(e),
                    bottom: ({
                        y: t
                    }, {
                        top: e
                    }) => parseFloat(e) + (t.max - t.min),
                    right: ({
                        x: t
                    }, {
                        left: e
                    }) => parseFloat(e) + (t.max - t.min),
                    x: en(4, 13),
                    y: en(5, 14)
                };
            eo.translateX = eo.x, eo.translateY = eo.y;
            let ea = new Set,
                el = !1,
                eu = !1;

            function eh() {
                if (eu) {
                    let t = Array.from(ea).filter(t => t.needsMeasurement),
                        e = new Set(t.map(t => t.element)),
                        i = new Map;
                    e.forEach(t => {
                        let e = function(t) {
                            let e = [];
                            return es.forEach(i => {
                                let n = t.getValue(i);
                                void 0 !== n && (e.push([i, n.get()]), n.set(+!!i.startsWith("scale")))
                            }), e
                        }(t);
                        e.length && (i.set(t, e), t.render())
                    }), t.forEach(t => t.measureInitialState()), e.forEach(t => {
                        t.render();
                        let e = i.get(t);
                        e && e.forEach(([e, i]) => {
                            var n;
                            null === (n = t.getValue(e)) || void 0 === n || n.set(i)
                        })
                    }), t.forEach(t => t.measureEndState()), t.forEach(t => {
                        void 0 !== t.suspendedScrollY && window.scrollTo(0, t.suspendedScrollY)
                    })
                }
                eu = !1, el = !1, ea.forEach(t => t.complete()), ea.clear()
            }

            function ed() {
                ea.forEach(t => {
                    t.readKeyframes(), t.needsMeasurement && (eu = !0)
                })
            }
            class ec {
                constructor(t, e, i, n, r, s = !1) {
                    this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...t], this.onComplete = e, this.name = i, this.motionValue = n, this.element = r, this.isAsync = s
                }
                scheduleResolve() {
                    this.isScheduled = !0, this.isAsync ? (ea.add(this), el || (el = !0, X.read(ed), X.resolveKeyframes(eh))) : (this.readKeyframes(), this.complete())
                }
                readKeyframes() {
                    let {
                        unresolvedKeyframes: t,
                        name: e,
                        element: i,
                        motionValue: n
                    } = this;
                    for (let r = 0; r < t.length; r++)
                        if (null === t[r]) {
                            if (0 === r) {
                                let r = null == n ? void 0 : n.get(),
                                    s = t[t.length - 1];
                                if (void 0 !== r) t[0] = r;
                                else if (i && e) {
                                    let n = i.readValue(e, s);
                                    null != n && (t[0] = n)
                                }
                                void 0 === t[0] && (t[0] = s), n && void 0 === r && n.set(t[0])
                            } else t[r] = t[r - 1]
                        }
                }
                setFinalKeyframe() {}
                measureInitialState() {}
                renderEndStyles() {}
                measureEndState() {}
                complete() {
                    this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), ea.delete(this)
                }
                cancel() {
                    this.isComplete || (this.isScheduled = !1, ea.delete(this))
                }
                resume() {
                    this.isComplete || this.scheduleResolve()
                }
            }
            let ep = t => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(t),
                ef = t => e => "string" == typeof e && e.startsWith(t),
                em = ef("--"),
                eg = ef("var(--"),
                ev = t => !!eg(t) && ey.test(t.split("/*")[0].trim()),
                ey = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,
                ex = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u,
                ew = t => e => e.test(t),
                eT = [tA, tU, tO, tN, tH, t$, {
                    test: t => "auto" === t,
                    parse: t => t
                }],
                eP = t => eT.find(ew(t));
            class eb extends ec {
                constructor(t, e, i, n, r) {
                    super(t, e, i, n, r, !0)
                }
                readKeyframes() {
                    let {
                        unresolvedKeyframes: t,
                        element: e,
                        name: i
                    } = this;
                    if (!e || !e.current) return;
                    super.readKeyframes();
                    for (let i = 0; i < t.length; i++) {
                        let n = t[i];
                        if ("string" == typeof n && ev(n = n.trim())) {
                            let r = function t(e, i, n = 1) {
                                F(n <= 4, `Max CSS variable fallback depth detected in property "${e}". This may indicate a circular fallback dependency.`);
                                let [r, s] = function(t) {
                                    let e = ex.exec(t);
                                    if (!e) return [, ];
                                    let [, i, n, r] = e;
                                    return [`--${null!=i?i:n}`, r]
                                }(e);
                                if (!r) return;
                                let o = window.getComputedStyle(i).getPropertyValue(r);
                                if (o) {
                                    let t = o.trim();
                                    return ep(t) ? parseFloat(t) : t
                                }
                                return ev(s) ? t(s, i, n + 1) : s
                            }(n, e.current);
                            void 0 !== r && (t[i] = r), i === t.length - 1 && (this.finalKeyframe = n)
                        }
                    }
                    if (this.resolveNoneKeyframes(), !U.has(i) || 2 !== t.length) return;
                    let [n, r] = t, s = eP(n), o = eP(r);
                    if (s !== o) {
                        if (ee(s) && ee(o))
                            for (let e = 0; e < t.length; e++) {
                                let i = t[e];
                                "string" == typeof i && (t[e] = parseFloat(i))
                            } else this.needsMeasurement = !0
                    }
                }
                resolveNoneKeyframes() {
                    let {
                        unresolvedKeyframes: t,
                        name: e
                    } = this, i = [];
                    for (let e = 0; e < t.length; e++) {
                        var n;
                        ("number" == typeof(n = t[e]) ? 0 === n : null === n || "none" === n || "0" === n || tb(n)) && i.push(e)
                    }
                    i.length && function(t, e, i) {
                        let n, r = 0;
                        for (; r < t.length && !n;) {
                            let e = t[r];
                            "string" == typeof e && !et.has(e) && tJ(e).values.length && (n = t[r]), r++
                        }
                        if (n && i)
                            for (let r of e) t[r] = t9(i, n)
                    }(t, i, e)
                }
                measureInitialState() {
                    let {
                        element: t,
                        unresolvedKeyframes: e,
                        name: i
                    } = this;
                    if (!t || !t.current) return;
                    "height" === i && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = eo[i](t.measureViewportBox(), window.getComputedStyle(t.current)), e[0] = this.measuredOrigin;
                    let n = e[e.length - 1];
                    void 0 !== n && t.getValue(i, n).jump(n, !1)
                }
                measureEndState() {
                    var t;
                    let {
                        element: e,
                        name: i,
                        unresolvedKeyframes: n
                    } = this;
                    if (!e || !e.current) return;
                    let r = e.getValue(i);
                    r && r.jump(this.measuredOrigin, !1);
                    let s = n.length - 1,
                        o = n[s];
                    n[s] = eo[i](e.measureViewportBox(), window.getComputedStyle(e.current)), null !== o && void 0 === this.finalKeyframe && (this.finalKeyframe = o), (null === (t = this.removedTransforms) || void 0 === t ? void 0 : t.length) && this.removedTransforms.forEach(([t, i]) => {
                        e.getValue(t).set(i)
                    }), this.resolveNoneKeyframes()
                }
            }
            let eE = (t, e) => "zIndex" !== e && !!("number" == typeof t || Array.isArray(t) || "string" == typeof t && (t0.test(t) || "0" === t) && !t.startsWith("url(")),
                eA = t => null !== t;

            function eS(t, {
                repeat: e,
                repeatType: i = "loop"
            }, n) {
                let r = t.filter(eA),
                    s = e && "loop" !== i && e % 2 == 1 ? 0 : r.length - 1;
                return s && void 0 !== n ? n : r[s]
            }
            class eC {
                constructor({
                    autoplay: t = !0,
                    delay: e = 0,
                    type: i = "keyframes",
                    repeat: n = 0,
                    repeatDelay: r = 0,
                    repeatType: s = "loop",
                    ...o
                }) {
                    this.isStopped = !1, this.hasAttemptedResolve = !1, this.createdAt = Z.now(), this.options = {
                        autoplay: t,
                        delay: e,
                        type: i,
                        repeat: n,
                        repeatDelay: r,
                        repeatType: s,
                        ...o
                    }, this.updateFinishedPromise()
                }
                calcStartTime() {
                    return this.resolvedAt && this.resolvedAt - this.createdAt > 40 ? this.resolvedAt : this.createdAt
                }
                get resolved() {
                    return this._resolved || this.hasAttemptedResolve || (ed(), eh()), this._resolved
                }
                onKeyframesResolved(t, e) {
                    this.resolvedAt = Z.now(), this.hasAttemptedResolve = !0;
                    let {
                        name: i,
                        type: n,
                        velocity: r,
                        delay: s,
                        onComplete: o,
                        onUpdate: a,
                        isGenerator: l
                    } = this.options;
                    if (!l && ! function(t, e, i, n) {
                            let r = t[0];
                            if (null === r) return !1;
                            if ("display" === e || "visibility" === e) return !0;
                            let s = t[t.length - 1],
                                o = eE(r, e),
                                a = eE(s, e);
                            return F(o === a, `You are trying to animate ${e} from "${r}" to "${s}". ${r} is not an animatable value - to enable this animation set ${r} to a value animatable to ${s} via the \`style\` property.`), !!o && !!a && (function(t) {
                                let e = t[0];
                                if (1 === t.length) return !0;
                                for (let i = 0; i < t.length; i++)
                                    if (t[i] !== e) return !0
                            }(t) || ("spring" === i || f(i)) && n)
                        }(t, i, n, r)) {
                        if (td.current || !s) {
                            a && a(eS(t, this.options, e)), o && o(), this.resolveFinishedPromise();
                            return
                        }
                        this.options.duration = 0
                    }
                    let u = this.initPlayback(t, e);
                    !1 !== u && (this._resolved = {
                        keyframes: t,
                        finalKeyframe: e,
                        ...u
                    }, this.onPostResolved())
                }
                onPostResolved() {}
                then(t, e) {
                    return this.currentFinishedPromise.then(t, e)
                }
                flatten() {
                    this.options.type = "keyframes", this.options.ease = "linear"
                }
                updateFinishedPromise() {
                    this.currentFinishedPromise = new Promise(t => {
                        this.resolveFinishedPromise = t
                    })
                }
            }
            let eM = {
                    layout: 0,
                    mainThread: 0,
                    waapi: 0
                },
                eR = (t, e, i) => t + (e - t) * i;

            function eV(t, e, i) {
                return (i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6) ? t + (e - t) * 6 * i : i < .5 ? e : i < 2 / 3 ? t + (e - t) * (2 / 3 - i) * 6 : t
            }

            function ek(t, e) {
                return i => i > 0 ? e : t
            }
            let eD = (t, e, i) => {
                    let n = t * t,
                        r = i * (e * e - n) + n;
                    return r < 0 ? 0 : Math.sqrt(r)
                },
                eL = [tI, tj, tY],
                eB = t => eL.find(e => e.test(t));

            function ej(t) {
                let e = eB(t);
                if (F(!!e, `'${t}' is not an animatable color. Use the equivalent color code instead.`), !e) return !1;
                let i = e.parse(t);
                return e === tY && (i = function({
                    hue: t,
                    saturation: e,
                    lightness: i,
                    alpha: n
                }) {
                    t /= 360, i /= 100;
                    let r = 0,
                        s = 0,
                        o = 0;
                    if (e /= 100) {
                        let n = i < .5 ? i * (1 + e) : i + e - i * e,
                            a = 2 * i - n;
                        r = eV(a, n, t + 1 / 3), s = eV(a, n, t), o = eV(a, n, t - 1 / 3)
                    } else r = s = o = i;
                    return {
                        red: Math.round(255 * r),
                        green: Math.round(255 * s),
                        blue: Math.round(255 * o),
                        alpha: n
                    }
                }(i)), i
            }
            let eI = (t, e) => {
                    let i = ej(t),
                        n = ej(e);
                    if (!i || !n) return ek(t, e);
                    let r = {
                        ...i
                    };
                    return t => (r.red = eD(i.red, n.red, t), r.green = eD(i.green, n.green, t), r.blue = eD(i.blue, n.blue, t), r.alpha = eR(i.alpha, n.alpha, t), tj.transform(r))
                },
                eF = (t, e) => i => e(t(i)),
                eN = (...t) => t.reduce(eF),
                eO = new Set(["none", "hidden"]);

            function eU(t, e) {
                return i => eR(t, e, i)
            }

            function e$(t) {
                return "number" == typeof t ? eU : "string" == typeof t ? ev(t) ? ek : tW.test(t) ? eI : eY : Array.isArray(t) ? eH : "object" == typeof t ? tW.test(t) ? eI : ez : ek
            }

            function eH(t, e) {
                let i = [...t],
                    n = i.length,
                    r = t.map((t, i) => e$(t)(t, e[i]));
                return t => {
                    for (let e = 0; e < n; e++) i[e] = r[e](t);
                    return i
                }
            }

            function ez(t, e) {
                let i = {
                        ...t,
                        ...e
                    },
                    n = {};
                for (let r in i) void 0 !== t[r] && void 0 !== e[r] && (n[r] = e$(t[r])(t[r], e[r]));
                return t => {
                    for (let e in n) i[e] = n[e](t);
                    return i
                }
            }
            let eY = (t, e) => {
                let i = t0.createTransformer(e),
                    n = tJ(t),
                    r = tJ(e);
                return n.indexes.var.length === r.indexes.var.length && n.indexes.color.length === r.indexes.color.length && n.indexes.number.length >= r.indexes.number.length ? eO.has(t) && !r.values.length || eO.has(e) && !n.values.length ? function(t, e) {
                    return eO.has(t) ? i => i <= 0 ? t : e : i => i >= 1 ? e : t
                }(t, e) : eN(eH(function(t, e) {
                    var i;
                    let n = [],
                        r = {
                            color: 0,
                            var: 0,
                            number: 0
                        };
                    for (let s = 0; s < e.values.length; s++) {
                        let o = e.types[s],
                            a = t.indexes[o][r[o]],
                            l = null !== (i = t.values[a]) && void 0 !== i ? i : 0;
                        n[s] = l, r[o]++
                    }
                    return n
                }(n, r), r.values), i) : (F(!0, `Complex values '${t}' and '${e}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), ek(t, e))
            };

            function eW(t, e, i) {
                return "number" == typeof t && "number" == typeof e && "number" == typeof i ? eR(t, e, i) : e$(t)(t, e)
            }

            function eK(t, e, i) {
                var n, r;
                let s = Math.max(e - 5, 0);
                return n = i - t(s), (r = e - s) ? 1e3 / r * n : 0
            }
            let e_ = {
                stiffness: 100,
                damping: 10,
                mass: 1,
                velocity: 0,
                duration: 800,
                bounce: .3,
                visualDuration: .3,
                restSpeed: {
                    granular: .01,
                    default: 2
                },
                restDelta: {
                    granular: .005,
                    default: .5
                },
                minDuration: .01,
                maxDuration: 10,
                minDamping: .05,
                maxDamping: 1
            };

            function eX(t, e) {
                return t * Math.sqrt(1 - e * e)
            }
            let eq = ["duration", "bounce"],
                eJ = ["stiffness", "damping", "mass"];

            function eQ(t, e) {
                return e.some(e => void 0 !== t[e])
            }

            function eG(t = e_.visualDuration, e = e_.bounce) {
                let i;
                let n = "object" != typeof t ? {
                        visualDuration: t,
                        keyframes: [0, 1],
                        bounce: e
                    } : t,
                    {
                        restSpeed: r,
                        restDelta: s
                    } = n,
                    o = n.keyframes[0],
                    a = n.keyframes[n.keyframes.length - 1],
                    l = {
                        done: !1,
                        value: o
                    },
                    {
                        stiffness: u,
                        damping: h,
                        mass: d,
                        duration: c,
                        velocity: f,
                        isResolvedFromDuration: m
                    } = function(t) {
                        let e = {
                            velocity: e_.velocity,
                            stiffness: e_.stiffness,
                            damping: e_.damping,
                            mass: e_.mass,
                            isResolvedFromDuration: !1,
                            ...t
                        };
                        if (!eQ(t, eJ) && eQ(t, eq)) {
                            if (t.visualDuration) {
                                let i = 2 * Math.PI / (1.2 * t.visualDuration),
                                    n = i * i,
                                    r = 2 * tE(.05, 1, 1 - (t.bounce || 0)) * Math.sqrt(n);
                                e = {
                                    ...e,
                                    mass: e_.mass,
                                    stiffness: n,
                                    damping: r
                                }
                            } else {
                                let i = function({
                                    duration: t = e_.duration,
                                    bounce: e = e_.bounce,
                                    velocity: i = e_.velocity,
                                    mass: n = e_.mass
                                }) {
                                    let r, s;
                                    F(t <= j(e_.maxDuration), "Spring duration must be 10 seconds or less");
                                    let o = 1 - e;
                                    o = tE(e_.minDamping, e_.maxDamping, o), t = tE(e_.minDuration, e_.maxDuration, I(t)), o < 1 ? (r = e => {
                                        let n = e * o,
                                            r = n * t;
                                        return .001 - (n - i) / eX(e, o) * Math.exp(-r)
                                    }, s = e => {
                                        let n = e * o * t,
                                            s = Math.pow(o, 2) * Math.pow(e, 2) * t,
                                            a = Math.exp(-n),
                                            l = eX(Math.pow(e, 2), o);
                                        return (n * i + i - s) * a * (-r(e) + .001 > 0 ? -1 : 1) / l
                                    }) : (r = e => -.001 + Math.exp(-e * t) * ((e - i) * t + 1), s = e => t * t * (i - e) * Math.exp(-e * t));
                                    let a = function(t, e, i) {
                                        let n = i;
                                        for (let i = 1; i < 12; i++) n -= t(n) / e(n);
                                        return n
                                    }(r, s, 5 / t);
                                    if (t = j(t), isNaN(a)) return {
                                        stiffness: e_.stiffness,
                                        damping: e_.damping,
                                        duration: t
                                    };
                                    {
                                        let e = Math.pow(a, 2) * n;
                                        return {
                                            stiffness: e,
                                            damping: 2 * o * Math.sqrt(n * e),
                                            duration: t
                                        }
                                    }
                                }(t);
                                (e = {
                                    ...e,
                                    ...i,
                                    mass: e_.mass
                                }).isResolvedFromDuration = !0
                            }
                        }
                        return e
                    }({
                        ...n,
                        velocity: -I(n.velocity || 0)
                    }),
                    g = f || 0,
                    v = h / (2 * Math.sqrt(u * d)),
                    y = a - o,
                    x = I(Math.sqrt(u / d)),
                    T = 5 > Math.abs(y);
                if (r || (r = T ? e_.restSpeed.granular : e_.restSpeed.default), s || (s = T ? e_.restDelta.granular : e_.restDelta.default), v < 1) {
                    let t = eX(x, v);
                    i = e => a - Math.exp(-v * x * e) * ((g + v * x * y) / t * Math.sin(t * e) + y * Math.cos(t * e))
                } else if (1 === v) i = t => a - Math.exp(-x * t) * (y + (g + x * y) * t);
                else {
                    let t = x * Math.sqrt(v * v - 1);
                    i = e => {
                        let i = Math.exp(-v * x * e),
                            n = Math.min(t * e, 300);
                        return a - i * ((g + v * x * y) * Math.sinh(n) + t * y * Math.cosh(n)) / t
                    }
                }
                let P = {
                    calculatedDuration: m && c || null,
                    next: t => {
                        let e = i(t);
                        if (m) l.done = t >= c;
                        else {
                            let n = 0;
                            v < 1 && (n = 0 === t ? j(g) : eK(i, t, e));
                            let o = Math.abs(n) <= r,
                                u = Math.abs(a - e) <= s;
                            l.done = o && u
                        }
                        return l.value = l.done ? a : e, l
                    },
                    toString: () => {
                        let t = Math.min(p(P), 2e4),
                            e = w(e => P.next(t * e).value, t, 30);
                        return t + "ms " + e
                    }
                };
                return P
            }

            function eZ({
                keyframes: t,
                velocity: e = 0,
                power: i = .8,
                timeConstant: n = 325,
                bounceDamping: r = 10,
                bounceStiffness: s = 500,
                modifyTarget: o,
                min: a,
                max: l,
                restDelta: u = .5,
                restSpeed: h
            }) {
                let d, c;
                let p = t[0],
                    f = {
                        done: !1,
                        value: p
                    },
                    m = t => void 0 !== a && t < a || void 0 !== l && t > l,
                    g = t => void 0 === a ? l : void 0 === l ? a : Math.abs(a - t) < Math.abs(l - t) ? a : l,
                    v = i * e,
                    y = p + v,
                    x = void 0 === o ? y : o(y);
                x !== y && (v = x - p);
                let w = t => -v * Math.exp(-t / n),
                    T = t => x + w(t),
                    P = t => {
                        let e = w(t),
                            i = T(t);
                        f.done = Math.abs(e) <= u, f.value = f.done ? x : i
                    },
                    b = t => {
                        m(f.value) && (d = t, c = eG({
                            keyframes: [f.value, g(f.value)],
                            velocity: eK(T, t, f.value),
                            damping: r,
                            stiffness: s,
                            restDelta: u,
                            restSpeed: h
                        }))
                    };
                return b(0), {
                    calculatedDuration: null,
                    next: t => {
                        let e = !1;
                        return (c || void 0 !== d || (e = !0, P(t), b(t)), void 0 !== d && t >= d) ? c.next(t - d) : (e || P(t), f)
                    }
                }
            }
            let e0 = tp(.42, 0, 1, 1),
                e1 = tp(0, 0, .58, 1),
                e2 = tp(.42, 0, .58, 1),
                e5 = t => Array.isArray(t) && "number" != typeof t[0],
                e3 = {
                    linear: F,
                    easeIn: e0,
                    easeInOut: e2,
                    easeOut: e1,
                    circIn: tw,
                    circInOut: tP,
                    circOut: tT,
                    backIn: tv,
                    backInOut: ty,
                    backOut: tg,
                    anticipate: tx
                },
                e4 = t => {
                    if (g(t)) {
                        F(4 === t.length, "Cubic bezier arrays must contain four numerical values.");
                        let [e, i, n, r] = t;
                        return tp(e, i, n, r)
                    }
                    return "string" == typeof t ? (F(void 0 !== e3[t], `Invalid easing type '${t}'`), e3[t]) : t
                };

            function e8({
                duration: t = 300,
                keyframes: e,
                times: i,
                ease: n = "easeInOut"
            }) {
                let r = e5(n) ? n.map(e4) : e4(n),
                    s = {
                        done: !1,
                        value: e[0]
                    },
                    o = function(t, e, {
                        clamp: i = !0,
                        ease: n,
                        mixer: r
                    } = {}) {
                        let s = t.length;
                        if (F(s === e.length, "Both input and output ranges must be the same length"), 1 === s) return () => e[0];
                        if (2 === s && e[0] === e[1]) return () => e[1];
                        let o = t[0] === t[1];
                        t[0] > t[s - 1] && (t = [...t].reverse(), e = [...e].reverse());
                        let a = function(t, e, i) {
                                let n = [],
                                    r = i || eW,
                                    s = t.length - 1;
                                for (let i = 0; i < s; i++) {
                                    let s = r(t[i], t[i + 1]);
                                    e && (s = eN(Array.isArray(e) ? e[i] || F : e, s)), n.push(s)
                                }
                                return n
                            }(e, n, r),
                            l = a.length,
                            u = i => {
                                if (o && i < t[0]) return e[0];
                                let n = 0;
                                if (l > 1)
                                    for (; n < t.length - 2 && !(i < t[n + 1]); n++);
                                let r = x(t[n], t[n + 1], i);
                                return a[n](r)
                            };
                        return i ? e => u(tE(t[0], t[s - 1], e)) : u
                    }((i && i.length === e.length ? i : function(t) {
                        let e = [0];
                        return function(t, e) {
                            let i = t[t.length - 1];
                            for (let n = 1; n <= e; n++) {
                                let r = x(0, e, n);
                                t.push(eR(i, 1, r))
                            }
                        }(e, t.length - 1), e
                    }(e)).map(e => e * t), e, {
                        ease: Array.isArray(r) ? r : e.map(() => r || e2).splice(0, e.length - 1)
                    });
                return {
                    calculatedDuration: t,
                    next: e => (s.value = o(e), s.done = e >= t, s)
                }
            }
            let e6 = t => {
                    let e = ({
                        timestamp: e
                    }) => t(e);
                    return {
                        start: () => X.update(e, !0),
                        stop: () => q(e),
                        now: () => J.isProcessing ? J.timestamp : Z.now()
                    }
                },
                e7 = {
                    decay: eZ,
                    inertia: eZ,
                    tween: e8,
                    keyframes: e8,
                    spring: eG
                },
                e9 = t => t / 100;
            class it extends eC {
                constructor(t) {
                    super(t), this.holdTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.startTime = null, this.state = "idle", this.stop = () => {
                        if (this.resolver.cancel(), this.isStopped = !0, "idle" === this.state) return;
                        this.teardown();
                        let {
                            onStop: t
                        } = this.options;
                        t && t()
                    };
                    let {
                        name: e,
                        motionValue: i,
                        element: n,
                        keyframes: r
                    } = this.options, s = (null == n ? void 0 : n.KeyframeResolver) || ec;
                    this.resolver = new s(r, (t, e) => this.onKeyframesResolved(t, e), e, i, n), this.resolver.scheduleResolve()
                }
                flatten() {
                    super.flatten(), this._resolved && Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes))
                }
                initPlayback(t) {
                    let e, i;
                    let {
                        type: n = "keyframes",
                        repeat: r = 0,
                        repeatDelay: s = 0,
                        repeatType: o,
                        velocity: a = 0
                    } = this.options, l = f(n) ? n : e7[n] || e8;
                    l !== e8 && "number" != typeof t[0] && (e = eN(e9, eW(t[0], t[1])), t = [0, 100]);
                    let u = l({
                        ...this.options,
                        keyframes: t
                    });
                    "mirror" === o && (i = l({
                        ...this.options,
                        keyframes: [...t].reverse(),
                        velocity: -a
                    })), null === u.calculatedDuration && (u.calculatedDuration = p(u));
                    let {
                        calculatedDuration: h
                    } = u, d = h + s;
                    return {
                        generator: u,
                        mirroredGenerator: i,
                        mapPercentToKeyframes: e,
                        calculatedDuration: h,
                        resolvedDuration: d,
                        totalDuration: d * (r + 1) - s
                    }
                }
                onPostResolved() {
                    let {
                        autoplay: t = !0
                    } = this.options;
                    eM.mainThread++, this.play(), "paused" !== this.pendingPlayState && t ? this.state = this.pendingPlayState : this.pause()
                }
                tick(t, e = !1) {
                    let {
                        resolved: i
                    } = this;
                    if (!i) {
                        let {
                            keyframes: t
                        } = this.options;
                        return {
                            done: !0,
                            value: t[t.length - 1]
                        }
                    }
                    let {
                        finalKeyframe: n,
                        generator: r,
                        mirroredGenerator: s,
                        mapPercentToKeyframes: o,
                        keyframes: a,
                        calculatedDuration: l,
                        totalDuration: u,
                        resolvedDuration: h
                    } = i;
                    if (null === this.startTime) return r.next(0);
                    let {
                        delay: d,
                        repeat: c,
                        repeatType: p,
                        repeatDelay: f,
                        onUpdate: m
                    } = this.options;
                    this.speed > 0 ? this.startTime = Math.min(this.startTime, t) : this.speed < 0 && (this.startTime = Math.min(t - u / this.speed, this.startTime)), e ? this.currentTime = t : null !== this.holdTime ? this.currentTime = this.holdTime : this.currentTime = Math.round(t - this.startTime) * this.speed;
                    let g = this.currentTime - d * (this.speed >= 0 ? 1 : -1),
                        v = this.speed >= 0 ? g < 0 : g > u;
                    this.currentTime = Math.max(g, 0), "finished" === this.state && null === this.holdTime && (this.currentTime = u);
                    let y = this.currentTime,
                        x = r;
                    if (c) {
                        let t = Math.min(this.currentTime, u) / h,
                            e = Math.floor(t),
                            i = t % 1;
                        !i && t >= 1 && (i = 1), 1 === i && e--, (e = Math.min(e, c + 1)) % 2 && ("reverse" === p ? (i = 1 - i, f && (i -= f / h)) : "mirror" === p && (x = s)), y = tE(0, 1, i) * h
                    }
                    let w = v ? {
                        done: !1,
                        value: a[0]
                    } : x.next(y);
                    o && (w.value = o(w.value));
                    let {
                        done: T
                    } = w;
                    v || null === l || (T = this.speed >= 0 ? this.currentTime >= u : this.currentTime <= 0);
                    let P = null === this.holdTime && ("finished" === this.state || "running" === this.state && T);
                    return P && void 0 !== n && (w.value = eS(a, this.options, n)), m && m(w.value), P && this.finish(), w
                }
                get duration() {
                    let {
                        resolved: t
                    } = this;
                    return t ? I(t.calculatedDuration) : 0
                }
                get time() {
                    return I(this.currentTime)
                }
                set time(t) {
                    t = j(t), this.currentTime = t, null !== this.holdTime || 0 === this.speed ? this.holdTime = t : this.driver && (this.startTime = this.driver.now() - t / this.speed)
                }
                get speed() {
                    return this.playbackSpeed
                }
                set speed(t) {
                    let e = this.playbackSpeed !== t;
                    this.playbackSpeed = t, e && (this.time = I(this.currentTime))
                }
                play() {
                    if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) {
                        this.pendingPlayState = "running";
                        return
                    }
                    if (this.isStopped) return;
                    let {
                        driver: t = e6,
                        onPlay: e,
                        startTime: i
                    } = this.options;
                    this.driver || (this.driver = t(t => this.tick(t))), e && e();
                    let n = this.driver.now();
                    null !== this.holdTime ? this.startTime = n - this.holdTime : this.startTime ? "finished" === this.state && (this.startTime = n) : this.startTime = null != i ? i : this.calcStartTime(), "finished" === this.state && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start()
                }
                pause() {
                    var t;
                    if (!this._resolved) {
                        this.pendingPlayState = "paused";
                        return
                    }
                    this.state = "paused", this.holdTime = null !== (t = this.currentTime) && void 0 !== t ? t : 0
                }
                complete() {
                    "running" !== this.state && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null
                }
                finish() {
                    this.teardown(), this.state = "finished";
                    let {
                        onComplete: t
                    } = this.options;
                    t && t()
                }
                cancel() {
                    null !== this.cancelTime && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise()
                }
                teardown() {
                    this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel(), eM.mainThread--
                }
                stopDriver() {
                    this.driver && (this.driver.stop(), this.driver = void 0)
                }
                sample(t) {
                    return this.startTime = 0, this.tick(t, !0)
                }
            }
            let ie = new Set(["opacity", "clipPath", "filter", "transform"]),
                ii = l(() => Object.hasOwnProperty.call(Element.prototype, "animate")),
                ir = {
                    anticipate: tx,
                    backInOut: ty,
                    circInOut: tP
                };
            class is extends eC {
                constructor(t) {
                    super(t);
                    let {
                        name: e,
                        motionValue: i,
                        element: n,
                        keyframes: r
                    } = this.options;
                    this.resolver = new eb(r, (t, e) => this.onKeyframesResolved(t, e), e, i, n), this.resolver.scheduleResolve()
                }
                initPlayback(t, e) {
                    var i;
                    let {
                        duration: n = 300,
                        times: r,
                        ease: s,
                        type: o,
                        motionValue: a,
                        name: l,
                        startTime: u
                    } = this.options;
                    if (!a.owner || !a.owner.current) return !1;
                    if ("string" == typeof s && y() && s in ir && (s = ir[s]), f((i = this.options).type) || "spring" === i.type || ! function t(e) {
                            return !!("function" == typeof e && y() || !e || "string" == typeof e && (e in P || y()) || g(e) || Array.isArray(e) && e.every(t))
                        }(i.ease)) {
                        let {
                            onComplete: e,
                            onUpdate: i,
                            motionValue: a,
                            element: l,
                            ...u
                        } = this.options, h = function(t, e) {
                            let i = new it({
                                    ...e,
                                    keyframes: t,
                                    repeat: 0,
                                    delay: 0,
                                    isGenerator: !0
                                }),
                                n = {
                                    done: !1,
                                    value: t[0]
                                },
                                r = [],
                                s = 0;
                            for (; !n.done && s < 2e4;) r.push((n = i.sample(s)).value), s += 10;
                            return {
                                times: void 0,
                                keyframes: r,
                                duration: s - 10,
                                ease: "linear"
                            }
                        }(t, u);
                        1 === (t = h.keyframes).length && (t[1] = t[0]), n = h.duration, r = h.times, s = h.ease, o = "keyframes"
                    }
                    let h = function(t, e, i, {
                        delay: n = 0,
                        duration: r = 300,
                        repeat: s = 0,
                        repeatType: o = "loop",
                        ease: a = "easeInOut",
                        times: l
                    } = {}) {
                        let u = {
                            [e]: i
                        };
                        l && (u.offset = l);
                        let h = function t(e, i) {
                            if (e) return "function" == typeof e && y() ? w(e, i) : g(e) ? T(e) : Array.isArray(e) ? e.map(e => t(e, i) || P.easeOut) : P[e]
                        }(a, r);
                        Array.isArray(h) && (u.easing = h), K.value && eM.waapi++;
                        let d = t.animate(u, {
                            delay: n,
                            duration: r,
                            easing: Array.isArray(h) ? "linear" : h,
                            fill: "both",
                            iterations: s + 1,
                            direction: "reverse" === o ? "alternate" : "normal"
                        });
                        return K.value && d.finished.finally(() => {
                            eM.waapi--
                        }), d
                    }(a.owner.current, l, t, {
                        ...this.options,
                        duration: n,
                        times: r,
                        ease: s
                    });
                    return h.startTime = null != u ? u : this.calcStartTime(), this.pendingTimeline ? (m(h, this.pendingTimeline), this.pendingTimeline = void 0) : h.onfinish = () => {
                        let {
                            onComplete: i
                        } = this.options;
                        a.set(eS(t, this.options, e)), i && i(), this.cancel(), this.resolveFinishedPromise()
                    }, {
                        animation: h,
                        duration: n,
                        times: r,
                        type: o,
                        ease: s,
                        keyframes: t
                    }
                }
                get duration() {
                    let {
                        resolved: t
                    } = this;
                    if (!t) return 0;
                    let {
                        duration: e
                    } = t;
                    return I(e)
                }
                get time() {
                    let {
                        resolved: t
                    } = this;
                    if (!t) return 0;
                    let {
                        animation: e
                    } = t;
                    return I(e.currentTime || 0)
                }
                set time(t) {
                    let {
                        resolved: e
                    } = this;
                    if (!e) return;
                    let {
                        animation: i
                    } = e;
                    i.currentTime = j(t)
                }
                get speed() {
                    let {
                        resolved: t
                    } = this;
                    if (!t) return 1;
                    let {
                        animation: e
                    } = t;
                    return e.playbackRate
                }
                set speed(t) {
                    let {
                        resolved: e
                    } = this;
                    if (!e) return;
                    let {
                        animation: i
                    } = e;
                    i.playbackRate = t
                }
                get state() {
                    let {
                        resolved: t
                    } = this;
                    if (!t) return "idle";
                    let {
                        animation: e
                    } = t;
                    return e.playState
                }
                get startTime() {
                    let {
                        resolved: t
                    } = this;
                    if (!t) return null;
                    let {
                        animation: e
                    } = t;
                    return e.startTime
                }
                attachTimeline(t) {
                    if (this._resolved) {
                        let {
                            resolved: e
                        } = this;
                        if (!e) return F;
                        let {
                            animation: i
                        } = e;
                        m(i, t)
                    } else this.pendingTimeline = t;
                    return F
                }
                play() {
                    if (this.isStopped) return;
                    let {
                        resolved: t
                    } = this;
                    if (!t) return;
                    let {
                        animation: e
                    } = t;
                    "finished" === e.playState && this.updateFinishedPromise(), e.play()
                }
                pause() {
                    let {
                        resolved: t
                    } = this;
                    if (!t) return;
                    let {
                        animation: e
                    } = t;
                    e.pause()
                }
                stop() {
                    if (this.resolver.cancel(), this.isStopped = !0, "idle" === this.state) return;
                    this.resolveFinishedPromise(), this.updateFinishedPromise();
                    let {
                        resolved: t
                    } = this;
                    if (!t) return;
                    let {
                        animation: e,
                        keyframes: i,
                        duration: n,
                        type: r,
                        ease: s,
                        times: o
                    } = t;
                    if ("idle" === e.playState || "finished" === e.playState) return;
                    if (this.time) {
                        let {
                            motionValue: t,
                            onUpdate: e,
                            onComplete: a,
                            element: l,
                            ...u
                        } = this.options, h = new it({
                            ...u,
                            keyframes: i,
                            duration: n,
                            type: r,
                            ease: s,
                            times: o,
                            isGenerator: !0
                        }), d = j(this.time);
                        t.setWithVelocity(h.sample(d - 10).value, h.sample(d).value, 10)
                    }
                    let {
                        onStop: a
                    } = this.options;
                    a && a(), this.cancel()
                }
                complete() {
                    let {
                        resolved: t
                    } = this;
                    t && t.animation.finish()
                }
                cancel() {
                    let {
                        resolved: t
                    } = this;
                    t && t.animation.cancel()
                }
                static supports(t) {
                    let {
                        motionValue: e,
                        name: i,
                        repeatDelay: n,
                        repeatType: r,
                        damping: s,
                        type: o
                    } = t;
                    if (!e || !e.owner || !(e.owner.current instanceof HTMLElement)) return !1;
                    let {
                        onUpdate: a,
                        transformTemplate: l
                    } = e.owner.getProps();
                    return ii() && i && ie.has(i) && !a && !l && !n && "mirror" !== r && 0 !== s && "inertia" !== o
                }
            }
            let io = {
                    type: "spring",
                    stiffness: 500,
                    damping: 25,
                    restSpeed: 10
                },
                ia = t => ({
                    type: "spring",
                    stiffness: 550,
                    damping: 0 === t ? 2 * Math.sqrt(550) : 30,
                    restSpeed: 10
                }),
                il = {
                    type: "keyframes",
                    duration: .8
                },
                iu = {
                    type: "keyframes",
                    ease: [.25, .1, .35, 1],
                    duration: .3
                },
                ih = (t, {
                    keyframes: e
                }) => e.length > 2 ? il : O.has(t) ? t.startsWith("scale") ? ia(e[1]) : io : iu,
                id = (t, e, i, n = {}, r, s) => o => {
                    let a = c(n, t) || {},
                        l = a.delay || n.delay || 0,
                        {
                            elapsed: u = 0
                        } = n;
                    u -= j(l);
                    let h = {
                        keyframes: Array.isArray(i) ? i : [null, i],
                        ease: "easeOut",
                        velocity: e.getVelocity(),
                        ...a,
                        delay: -u,
                        onUpdate: t => {
                            e.set(t), a.onUpdate && a.onUpdate(t)
                        },
                        onComplete: () => {
                            o(), a.onComplete && a.onComplete()
                        },
                        name: t,
                        motionValue: e,
                        element: s ? void 0 : r
                    };
                    ! function({
                        when: t,
                        delay: e,
                        delayChildren: i,
                        staggerChildren: n,
                        staggerDirection: r,
                        repeat: s,
                        repeatType: o,
                        repeatDelay: a,
                        from: l,
                        elapsed: u,
                        ...h
                    }) {
                        return !!Object.keys(h).length
                    }(a) && (h = {
                        ...h,
                        ...ih(t, h)
                    }), h.duration && (h.duration = j(h.duration)), h.repeatDelay && (h.repeatDelay = j(h.repeatDelay)), void 0 !== h.from && (h.keyframes[0] = h.from);
                    let p = !1;
                    if (!1 !== h.type && (0 !== h.duration || h.repeatDelay) || (h.duration = 0, 0 !== h.delay || (p = !0)), (td.current || Y.skipAnimations) && (p = !0, h.duration = 0, h.delay = 0), p && !s && void 0 !== e.get()) {
                        let t = eS(h.keyframes, a);
                        if (void 0 !== t) return X.update(() => {
                            h.onUpdate(t), h.onComplete()
                        }), new d([])
                    }
                    return !s && is.supports(h) ? new is(h) : new it(h)
                };

            function ic(t, e, {
                delay: i = 0,
                transitionOverride: n,
                type: r
            } = {}) {
                var s;
                let {
                    transition: o = t.getDefaultTransition(),
                    transitionEnd: l,
                    ...u
                } = e;
                n && (o = n);
                let h = [],
                    d = r && t.animationState && t.animationState.getState()[r];
                for (let e in u) {
                    let n = t.getValue(e, null !== (s = t.latestValues[e]) && void 0 !== s ? s : null),
                        r = u[e];
                    if (void 0 === r || d && function({
                            protectedKeys: t,
                            needsAnimating: e
                        }, i) {
                            let n = t.hasOwnProperty(i) && !0 !== e[i];
                            return e[i] = !1, n
                        }(d, e)) continue;
                    let a = {
                            delay: i,
                            ...c(o || {}, e)
                        },
                        l = !1;
                    if (window.MotionHandoffAnimation) {
                        let i = t.props[th];
                        if (i) {
                            let t = window.MotionHandoffAnimation(i, e, X);
                            null !== t && (a.startTime = t, l = !0)
                        }
                    }
                    tl(t, e), n.start(id(e, n, r, t.shouldReduceMotion && U.has(e) ? {
                        type: !1
                    } : a, t, l));
                    let p = n.animation;
                    p && h.push(p)
                }
                return l && Promise.all(h).then(() => {
                    X.update(() => {
                        l && function(t, e) {
                            let {
                                transitionEnd: i = {},
                                transition: n = {},
                                ...r
                            } = a(t, e) || {};
                            for (let e in r = {
                                    ...r,
                                    ...i
                                }) {
                                let i = z(r[e]);
                                t.hasValue(e) ? t.getValue(e).set(i) : t.addValue(e, to(i))
                            }
                        }(t, l)
                    })
                }), h
            }

            function ip(t, e, i = {}) {
                var n;
                let r = a(t, e, "exit" === i.type ? null === (n = t.presenceContext) || void 0 === n ? void 0 : n.custom : void 0),
                    {
                        transition: s = t.getDefaultTransition() || {}
                    } = r || {};
                i.transitionOverride && (s = i.transitionOverride);
                let o = r ? () => Promise.all(ic(t, r, i)) : () => Promise.resolve(),
                    l = t.variantChildren && t.variantChildren.size ? (n = 0) => {
                        let {
                            delayChildren: r = 0,
                            staggerChildren: o,
                            staggerDirection: a
                        } = s;
                        return function(t, e, i = 0, n = 0, r = 1, s) {
                            let o = [],
                                a = (t.variantChildren.size - 1) * n,
                                l = 1 === r ? (t = 0) => t * n : (t = 0) => a - t * n;
                            return Array.from(t.variantChildren).sort(im).forEach((t, n) => {
                                t.notify("AnimationStart", e), o.push(ip(t, e, {
                                    ...s,
                                    delay: i + l(n)
                                }).then(() => t.notify("AnimationComplete", e)))
                            }), Promise.all(o)
                        }(t, e, r + n, o, a, i)
                    } : () => Promise.resolve(),
                    {
                        when: u
                    } = s;
                if (!u) return Promise.all([o(), l(i.delay)]);
                {
                    let [t, e] = "beforeChildren" === u ? [o, l] : [l, o];
                    return t().then(() => e())
                }
            }

            function im(t, e) {
                return t.sortNodePosition(e)
            }

            function ig(t, e) {
                if (!Array.isArray(e)) return !1;
                let i = e.length;
                if (i !== t.length) return !1;
                for (let n = 0; n < i; n++)
                    if (e[n] !== t[n]) return !1;
                return !0
            }

            function iv(t) {
                return "string" == typeof t || Array.isArray(t)
            }
            let iy = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"],
                ix = ["initial", ...iy],
                iw = ix.length,
                iT = [...iy].reverse(),
                iP = iy.length;

            function ib(t = !1) {
                return {
                    isActive: t,
                    protectedKeys: {},
                    needsAnimating: {},
                    prevResolvedValues: {}
                }
            }

            function iE() {
                return {
                    animate: ib(!0),
                    whileInView: ib(),
                    whileHover: ib(),
                    whileTap: ib(),
                    whileDrag: ib(),
                    whileFocus: ib(),
                    exit: ib()
                }
            }
            class iA {
                constructor(t) {
                    this.isMounted = !1, this.node = t
                }
                update() {}
            }
            class iS extends iA {
                constructor(t) {
                    super(t), t.animationState || (t.animationState = function(t) {
                        let e = e => Promise.all(e.map(({
                                animation: e,
                                options: i
                            }) => (function(t, e, i = {}) {
                                let n;
                                if (t.notify("AnimationStart", e), Array.isArray(e)) n = Promise.all(e.map(e => ip(t, e, i)));
                                else if ("string" == typeof e) n = ip(t, e, i);
                                else {
                                    let r = "function" == typeof e ? a(t, e, i.custom) : e;
                                    n = Promise.all(ic(t, r, i))
                                }
                                return n.then(() => {
                                    t.notify("AnimationComplete", e)
                                })
                            })(t, e, i))),
                            i = iE(),
                            n = !0,
                            s = e => (i, n) => {
                                var r;
                                let s = a(t, n, "exit" === e ? null === (r = t.presenceContext) || void 0 === r ? void 0 : r.custom : void 0);
                                if (s) {
                                    let {
                                        transition: t,
                                        transitionEnd: e,
                                        ...n
                                    } = s;
                                    i = {
                                        ...i,
                                        ...n,
                                        ...e
                                    }
                                }
                                return i
                            };

                        function o(o) {
                            let {
                                props: l
                            } = t, u = function t(e) {
                                if (!e) return;
                                if (!e.isControllingVariants) {
                                    let i = e.parent && t(e.parent) || {};
                                    return void 0 !== e.props.initial && (i.initial = e.props.initial), i
                                }
                                let i = {};
                                for (let t = 0; t < iw; t++) {
                                    let n = ix[t],
                                        r = e.props[n];
                                    (iv(r) || !1 === r) && (i[n] = r)
                                }
                                return i
                            }(t.parent) || {}, h = [], d = new Set, c = {}, p = 1 / 0;
                            for (let e = 0; e < iP; e++) {
                                var f, m;
                                let a = iT[e],
                                    g = i[a],
                                    v = void 0 !== l[a] ? l[a] : u[a],
                                    y = iv(v),
                                    x = a === o ? g.isActive : null;
                                !1 === x && (p = e);
                                let w = v === u[a] && v !== l[a] && y;
                                if (w && n && t.manuallyAnimateOnMount && (w = !1), g.protectedKeys = {
                                        ...c
                                    }, !g.isActive && null === x || !v && !g.prevProp || r(v) || "boolean" == typeof v) continue;
                                let T = (f = g.prevProp, "string" == typeof(m = v) ? m !== f : !!Array.isArray(m) && !ig(m, f)),
                                    P = T || a === o && g.isActive && !w && y || e > p && y,
                                    b = !1,
                                    E = Array.isArray(v) ? v : [v],
                                    A = E.reduce(s(a), {});
                                !1 === x && (A = {});
                                let {
                                    prevResolvedValues: S = {}
                                } = g, C = {
                                    ...S,
                                    ...A
                                }, M = e => {
                                    P = !0, d.has(e) && (b = !0, d.delete(e)), g.needsAnimating[e] = !0;
                                    let i = t.getValue(e);
                                    i && (i.liveStyle = !1)
                                };
                                for (let t in C) {
                                    let e = A[t],
                                        i = S[t];
                                    if (c.hasOwnProperty(t)) continue;
                                    let n = !1;
                                    ($(e) && $(i) ? ig(e, i) : e === i) ? void 0 !== e && d.has(t) ? M(t) : g.protectedKeys[t] = !0: null != e ? M(t) : d.add(t)
                                }
                                g.prevProp = v, g.prevResolvedValues = A, g.isActive && (c = {
                                    ...c,
                                    ...A
                                }), n && t.blockInitialAnimation && (P = !1);
                                let R = !(w && T) || b;
                                P && R && h.push(...E.map(t => ({
                                    animation: t,
                                    options: {
                                        type: a
                                    }
                                })))
                            }
                            if (d.size) {
                                let e = {};
                                if ("boolean" != typeof l.initial) {
                                    let i = a(t, Array.isArray(l.initial) ? l.initial[0] : l.initial);
                                    i && i.transition && (e.transition = i.transition)
                                }
                                d.forEach(i => {
                                    let n = t.getBaseTarget(i),
                                        r = t.getValue(i);
                                    r && (r.liveStyle = !0), e[i] = null != n ? n : null
                                }), h.push({
                                    animation: e
                                })
                            }
                            let g = !!h.length;
                            return n && (!1 === l.initial || l.initial === l.animate) && !t.manuallyAnimateOnMount && (g = !1), n = !1, g ? e(h) : Promise.resolve()
                        }
                        return {
                            animateChanges: o,
                            setActive: function(e, n) {
                                var r;
                                if (i[e].isActive === n) return Promise.resolve();
                                null === (r = t.variantChildren) || void 0 === r || r.forEach(t => {
                                    var i;
                                    return null === (i = t.animationState) || void 0 === i ? void 0 : i.setActive(e, n)
                                }), i[e].isActive = n;
                                let s = o(e);
                                for (let t in i) i[t].protectedKeys = {};
                                return s
                            },
                            setAnimateFunction: function(i) {
                                e = i(t)
                            },
                            getState: () => i,
                            reset: () => {
                                i = iE(), n = !0
                            }
                        }
                    }(t))
                }
                updateAnimationControlsSubscription() {
                    let {
                        animate: t
                    } = this.node.getProps();
                    r(t) && (this.unmountControls = t.subscribe(this.node))
                }
                mount() {
                    this.updateAnimationControlsSubscription()
                }
                update() {
                    let {
                        animate: t
                    } = this.node.getProps(), {
                        animate: e
                    } = this.node.prevProps || {};
                    t !== e && this.updateAnimationControlsSubscription()
                }
                unmount() {
                    var t;
                    this.node.animationState.reset(), null === (t = this.unmountControls) || void 0 === t || t.call(this)
                }
            }
            let iC = 0;
            class iM extends iA {
                constructor() {
                    super(...arguments), this.id = iC++
                }
                update() {
                    if (!this.node.presenceContext) return;
                    let {
                        isPresent: t,
                        onExitComplete: e
                    } = this.node.presenceContext, {
                        isPresent: i
                    } = this.node.prevPresenceContext || {};
                    if (!this.node.animationState || t === i) return;
                    let n = this.node.animationState.setActive("exit", !t);
                    e && !t && n.then(() => {
                        e(this.id)
                    })
                }
                mount() {
                    let {
                        register: t,
                        onExitComplete: e
                    } = this.node.presenceContext || {};
                    e && e(this.id), t && (this.unmount = t(this.id))
                }
                unmount() {}
            }

            function iR(t, e, i, n = {
                passive: !0
            }) {
                return t.addEventListener(e, i, n), () => t.removeEventListener(e, i)
            }

            function iV(t) {
                return {
                    point: {
                        x: t.pageX,
                        y: t.pageY
                    }
                }
            }
            let ik = t => e => M(e) && t(e, iV(e));

            function iD(t, e, i, n) {
                return iR(t, e, ik(i), n)
            }

            function iL({
                top: t,
                left: e,
                right: i,
                bottom: n
            }) {
                return {
                    x: {
                        min: e,
                        max: i
                    },
                    y: {
                        min: t,
                        max: n
                    }
                }
            }

            function iB(t) {
                return t.max - t.min
            }

            function ij(t, e, i, n = .5) {
                t.origin = n, t.originPoint = eR(e.min, e.max, t.origin), t.scale = iB(i) / iB(e), t.translate = eR(i.min, i.max, t.origin) - t.originPoint, (t.scale >= .9999 && t.scale <= 1.0001 || isNaN(t.scale)) && (t.scale = 1), (t.translate >= -.01 && t.translate <= .01 || isNaN(t.translate)) && (t.translate = 0)
            }

            function iI(t, e, i, n) {
                ij(t.x, e.x, i.x, n ? n.originX : void 0), ij(t.y, e.y, i.y, n ? n.originY : void 0)
            }

            function iF(t, e, i) {
                t.min = i.min + e.min, t.max = t.min + iB(e)
            }

            function iN(t, e, i) {
                t.min = e.min - i.min, t.max = t.min + iB(e)
            }

            function iO(t, e, i) {
                iN(t.x, e.x, i.x), iN(t.y, e.y, i.y)
            }
            let iU = () => ({
                    translate: 0,
                    scale: 1,
                    origin: 0,
                    originPoint: 0
                }),
                i$ = () => ({
                    x: iU(),
                    y: iU()
                }),
                iH = () => ({
                    min: 0,
                    max: 0
                }),
                iz = () => ({
                    x: iH(),
                    y: iH()
                });

            function iY(t) {
                return [t("x"), t("y")]
            }

            function iW(t) {
                return void 0 === t || 1 === t
            }

            function iK({
                scale: t,
                scaleX: e,
                scaleY: i
            }) {
                return !iW(t) || !iW(e) || !iW(i)
            }

            function i_(t) {
                return iK(t) || iX(t) || t.z || t.rotate || t.rotateX || t.rotateY || t.skewX || t.skewY
            }

            function iX(t) {
                var e, i;
                return (e = t.x) && "0%" !== e || (i = t.y) && "0%" !== i
            }

            function iq(t, e, i, n, r) {
                return void 0 !== r && (t = n + r * (t - n)), n + i * (t - n) + e
            }

            function iJ(t, e = 0, i = 1, n, r) {
                t.min = iq(t.min, e, i, n, r), t.max = iq(t.max, e, i, n, r)
            }

            function iQ(t, {
                x: e,
                y: i
            }) {
                iJ(t.x, e.translate, e.scale, e.originPoint), iJ(t.y, i.translate, i.scale, i.originPoint)
            }

            function iG(t, e) {
                t.min = t.min + e, t.max = t.max + e
            }

            function iZ(t, e, i, n, r = .5) {
                let s = eR(t.min, t.max, r);
                iJ(t, e, i, s, n)
            }

            function i0(t, e) {
                iZ(t.x, e.x, e.scaleX, e.scale, e.originX), iZ(t.y, e.y, e.scaleY, e.scale, e.originY)
            }

            function i1(t, e) {
                return iL(function(t, e) {
                    if (!e) return t;
                    let i = e({
                            x: t.left,
                            y: t.top
                        }),
                        n = e({
                            x: t.right,
                            y: t.bottom
                        });
                    return {
                        top: i.y,
                        left: i.x,
                        bottom: n.y,
                        right: n.x
                    }
                }(t.getBoundingClientRect(), e))
            }

            function i2(t) {
                return t && "object" == typeof t && Object.prototype.hasOwnProperty.call(t, "current")
            }
            let i5 = (t, e) => Math.abs(t - e);
            class i3 {
                constructor(t, e, {
                    transformPagePoint: i,
                    dragSnapToOrigin: n = !1
                } = {}) {
                    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.updatePoint = () => {
                            if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
                            let t = i6(this.lastMoveEventInfo, this.history),
                                e = null !== this.startEvent,
                                i = function(t, e) {
                                    return Math.sqrt(i5(t.x, e.x) ** 2 + i5(t.y, e.y) ** 2)
                                }(t.offset, {
                                    x: 0,
                                    y: 0
                                }) >= 3;
                            if (!e && !i) return;
                            let {
                                point: n
                            } = t, {
                                timestamp: r
                            } = J;
                            this.history.push({
                                ...n,
                                timestamp: r
                            });
                            let {
                                onStart: s,
                                onMove: o
                            } = this.handlers;
                            e || (s && s(this.lastMoveEvent, t), this.startEvent = this.lastMoveEvent), o && o(this.lastMoveEvent, t)
                        }, this.handlePointerMove = (t, e) => {
                            if (this.index = i9(t.currentTarget), t.target instanceof Element && t.target.hasPointerCapture && void 0 !== t.pointerId) try {
                                if (!t.target.hasPointerCapture(t.pointerId)) return
                            } catch (t) {}
                            this.lastMoveEvent = t, this.lastMoveEventInfo = i4(e, this.transformPagePoint), X.update(this.updatePoint, !0)
                        }, this.handlePointerUp = (t, e) => {
                            S(t, "release"), this.end();
                            let {
                                onEnd: i,
                                onSessionEnd: n,
                                resumeAnimation: r
                            } = this.handlers;
                            if (this.dragSnapToOrigin && r && r(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return;
                            let s = i6("pointercancel" === t.type || "lostpointercapture" === t.type ? this.lastMoveEventInfo : i4(e, this.transformPagePoint), this.history);
                            this.startEvent && i && i(t, s), n && n(t, s)
                        }, !M(t)) return;
                    this.dragSnapToOrigin = n, this.handlers = e, this.transformPagePoint = i;
                    let r = i4(iV(t), this.transformPagePoint),
                        {
                            point: s
                        } = r,
                        {
                            timestamp: o
                        } = J;
                    this.history = [{
                        ...s,
                        timestamp: o
                    }];
                    let {
                        onSessionStart: a
                    } = e;
                    a && a(t, i6(r, this.history)), S(t, "set"), this.removeListeners = eN(iD(t.currentTarget, "pointermove", this.handlePointerMove), iD(t.currentTarget, "pointerup", this.handlePointerUp), iD(t.currentTarget, "pointercancel", this.handlePointerUp), iD(t.currentTarget, "lostpointercapture", (t, e) => {
                        i9(t.currentTarget) !== this.index ? S(t, "set") : this.handlePointerUp(t, e)
                    }))
                }
                updateHandlers(t) {
                    this.handlers = t
                }
                end() {
                    this.removeListeners && this.removeListeners(), q(this.updatePoint)
                }
            }

            function i4(t, e) {
                return e ? {
                    point: e(t.point)
                } : t
            }

            function i8(t, e) {
                return {
                    x: t.x - e.x,
                    y: t.y - e.y
                }
            }

            function i6({
                point: t
            }, e) {
                return {
                    point: t,
                    delta: i8(t, i7(e)),
                    offset: i8(t, e[0]),
                    velocity: function(t, e) {
                        if (t.length < 2) return {
                            x: 0,
                            y: 0
                        };
                        let i = t.length - 1,
                            n = null,
                            r = i7(t);
                        for (; i >= 0 && (n = t[i], !(r.timestamp - n.timestamp > j(.1)));) i--;
                        if (!n) return {
                            x: 0,
                            y: 0
                        };
                        let s = I(r.timestamp - n.timestamp);
                        if (0 === s) return {
                            x: 0,
                            y: 0
                        };
                        let o = {
                            x: (r.x - n.x) / s,
                            y: (r.y - n.y) / s
                        };
                        return o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o
                    }(e, .1)
                }
            }

            function i7(t) {
                return t[t.length - 1]
            }

            function i9(t) {
                return t.parentNode ? Array.from(t.parentNode.children).indexOf(t) : -1
            }

            function nt(t, e, i) {
                return {
                    min: void 0 !== e ? t.min + e : void 0,
                    max: void 0 !== i ? t.max + i - (t.max - t.min) : void 0
                }
            }

            function ne(t, e) {
                let i = e.min - t.min,
                    n = e.max - t.max;
                return e.max - e.min < t.max - t.min && ([i, n] = [n, i]), {
                    min: i,
                    max: n
                }
            }

            function ni(t, e, i) {
                return {
                    min: nn(t, e),
                    max: nn(t, i)
                }
            }

            function nn(t, e) {
                return "number" == typeof t ? t : t[e] || 0
            }
            let nr = new WeakMap;
            class ns {
                constructor(t) {
                    this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = {
                        x: 0,
                        y: 0
                    }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = iz(), this.visualElement = t
                }
                start(t, {
                    snapToCursor: e = !1
                } = {}) {
                    let {
                        presenceContext: i
                    } = this.visualElement;
                    if (i && !1 === i.isPresent) return;
                    let {
                        dragSnapToOrigin: n
                    } = this.getProps();
                    this.panSession = new i3(t, {
                        onSessionStart: t => {
                            let {
                                dragSnapToOrigin: i
                            } = this.getProps();
                            i ? this.pauseAnimation() : this.stopAnimation(), e && this.snapToCursor(iV(t).point)
                        },
                        onStart: (t, e) => {
                            var i;
                            let {
                                drag: n,
                                dragPropagation: r,
                                onDragStart: s
                            } = this.getProps();
                            if (n && !r && (this.openDragLock && this.openDragLock(), this.openDragLock = "x" === (i = n) || "y" === i ? b[i] ? null : (b[i] = !0, () => {
                                    b[i] = !1
                                }) : b.x || b.y ? null : (b.x = b.y = !0, () => {
                                    b.x = b.y = !1
                                }), !this.openDragLock)) return;
                            this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), iY(t => {
                                let e = this.getAxisMotionValue(t).get() || 0;
                                if (tO.test(e)) {
                                    let {
                                        projection: i
                                    } = this.visualElement;
                                    if (i && i.layout) {
                                        let n = i.layout.layoutBox[t];
                                        n && (e = iB(n) * (parseFloat(e) / 100))
                                    }
                                }
                                this.originPoint[t] = e
                            }), s && X.postRender(() => s(t, e)), tl(this.visualElement, "transform");
                            let {
                                animationState: o
                            } = this.visualElement;
                            o && o.setActive("whileDrag", !0)
                        },
                        onMove: (t, e) => {
                            let {
                                dragPropagation: i,
                                dragDirectionLock: n,
                                onDirectionLock: r,
                                onDrag: s
                            } = this.getProps();
                            if (!i && !this.openDragLock) return;
                            let {
                                offset: o
                            } = e;
                            if (n && null === this.currentDirection) {
                                this.currentDirection = function(t, e = 10) {
                                    let i = null;
                                    return Math.abs(t.y) > e ? i = "y" : Math.abs(t.x) > e && (i = "x"), i
                                }(o), null !== this.currentDirection && r && r(this.currentDirection);
                                return
                            }
                            this.updateAxis("x", e.point, o), this.updateAxis("y", e.point, o), this.visualElement.render(), s && s(t, e)
                        },
                        onSessionEnd: (t, e) => this.stop(t, e),
                        resumeAnimation: () => iY(t => {
                            var e;
                            return "paused" === this.getAnimationState(t) && (null === (e = this.getAxisMotionValue(t).animation) || void 0 === e ? void 0 : e.play())
                        })
                    }, {
                        transformPagePoint: this.visualElement.getTransformPagePoint(),
                        dragSnapToOrigin: n
                    })
                }
                stop(t, e) {
                    let i = this.isDragging;
                    if (this.cancel(), !i) return;
                    let {
                        velocity: n
                    } = e;
                    this.startAnimation(n);
                    let {
                        onDragEnd: r
                    } = this.getProps();
                    r && X.postRender(() => r(t, e))
                }
                cancel() {
                    this.isDragging = !1;
                    let {
                        projection: t,
                        animationState: e
                    } = this.visualElement;
                    t && (t.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
                    let {
                        dragPropagation: i
                    } = this.getProps();
                    !i && this.openDragLock && (this.openDragLock(), this.openDragLock = null), e && e.setActive("whileDrag", !1)
                }
                updateAxis(t, e, i) {
                    let {
                        drag: n
                    } = this.getProps();
                    if (!i || !no(t, n, this.currentDirection)) return;
                    let r = this.getAxisMotionValue(t),
                        s = this.originPoint[t] + i[t];
                    this.constraints && this.constraints[t] && (s = function(t, {
                        min: e,
                        max: i
                    }, n) {
                        return void 0 !== e && t < e ? t = n ? eR(e, t, n.min) : Math.max(t, e) : void 0 !== i && t > i && (t = n ? eR(i, t, n.max) : Math.min(t, i)), t
                    }(s, this.constraints[t], this.elastic[t])), r.set(s)
                }
                resolveConstraints() {
                    var t;
                    let {
                        dragConstraints: e,
                        dragElastic: i
                    } = this.getProps(), n = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : null === (t = this.visualElement.projection) || void 0 === t ? void 0 : t.layout, r = this.constraints;
                    e && i2(e) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : e && n ? this.constraints = function(t, {
                        top: e,
                        left: i,
                        bottom: n,
                        right: r
                    }) {
                        return {
                            x: nt(t.x, i, r),
                            y: nt(t.y, e, n)
                        }
                    }(n.layoutBox, e) : this.constraints = !1, this.elastic = function(t = .35) {
                        return !1 === t ? t = 0 : !0 === t && (t = .35), {
                            x: ni(t, "left", "right"),
                            y: ni(t, "top", "bottom")
                        }
                    }(i), r !== this.constraints && n && this.constraints && !this.hasMutatedConstraints && iY(t => {
                        !1 !== this.constraints && this.getAxisMotionValue(t) && (this.constraints[t] = function(t, e) {
                            let i = {};
                            return void 0 !== e.min && (i.min = e.min - t.min), void 0 !== e.max && (i.max = e.max - t.min), i
                        }(n.layoutBox[t], this.constraints[t]))
                    })
                }
                resolveRefConstraints() {
                    var t;
                    let {
                        dragConstraints: e,
                        onMeasureDragConstraints: i
                    } = this.getProps();
                    if (!e || !i2(e)) return !1;
                    let n = e.current;
                    F(null !== n, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
                    let {
                        projection: r
                    } = this.visualElement;
                    if (!r || !r.layout) return !1;
                    let s = function(t, e, i) {
                            let n = i1(t, i),
                                {
                                    scroll: r
                                } = e;
                            return r && (iG(n.x, r.offset.x), iG(n.y, r.offset.y)), n
                        }(n, r.root, this.visualElement.getTransformPagePoint()),
                        o = {
                            x: ne((t = r.layout.layoutBox).x, s.x),
                            y: ne(t.y, s.y)
                        };
                    if (i) {
                        let t = i(function({
                            x: t,
                            y: e
                        }) {
                            return {
                                top: e.min,
                                right: t.max,
                                bottom: e.max,
                                left: t.min
                            }
                        }(o));
                        this.hasMutatedConstraints = !!t, t && (o = iL(t))
                    }
                    return o
                }
                startAnimation(t) {
                    let {
                        drag: e,
                        dragMomentum: i,
                        dragElastic: n,
                        dragTransition: r,
                        dragSnapToOrigin: s,
                        onDragTransitionEnd: o
                    } = this.getProps(), a = this.constraints || {};
                    return Promise.all(iY(o => {
                        if (!no(o, e, this.currentDirection)) return;
                        let l = a && a[o] || {};
                        s && (l = {
                            min: 0,
                            max: 0
                        });
                        let u = {
                            type: "inertia",
                            velocity: i ? t[o] : 0,
                            bounceStiffness: n ? 200 : 1e6,
                            bounceDamping: n ? 40 : 1e7,
                            timeConstant: 750,
                            restDelta: 1,
                            restSpeed: 10,
                            ...r,
                            ...l
                        };
                        return this.startAxisValueAnimation(o, u)
                    })).then(o)
                }
                startAxisValueAnimation(t, e) {
                    let i = this.getAxisMotionValue(t);
                    return tl(this.visualElement, t), i.start(id(t, i, 0, e, this.visualElement, !1))
                }
                stopAnimation() {
                    iY(t => this.getAxisMotionValue(t).stop())
                }
                pauseAnimation() {
                    iY(t => {
                        var e;
                        return null === (e = this.getAxisMotionValue(t).animation) || void 0 === e ? void 0 : e.pause()
                    })
                }
                getAnimationState(t) {
                    var e;
                    return null === (e = this.getAxisMotionValue(t).animation) || void 0 === e ? void 0 : e.state
                }
                getAxisMotionValue(t) {
                    let e = `_drag${t.toUpperCase()}`,
                        i = this.visualElement.getProps();
                    return i[e] || this.visualElement.getValue(t, (i.initial ? i.initial[t] : void 0) || 0)
                }
                snapToCursor(t) {
                    iY(e => {
                        let {
                            drag: i
                        } = this.getProps();
                        if (!no(e, i, this.currentDirection)) return;
                        let {
                            projection: n
                        } = this.visualElement, r = this.getAxisMotionValue(e);
                        if (n && n.layout) {
                            let {
                                min: i,
                                max: s
                            } = n.layout.layoutBox[e];
                            r.set(t[e] - eR(i, s, .5))
                        }
                    })
                }
                scalePositionWithinConstraints() {
                    if (!this.visualElement.current) return;
                    let {
                        drag: t,
                        dragConstraints: e
                    } = this.getProps(), {
                        projection: i
                    } = this.visualElement;
                    if (!i2(e) || !i || !this.constraints) return;
                    this.stopAnimation();
                    let n = {
                        x: 0,
                        y: 0
                    };
                    iY(t => {
                        let e = this.getAxisMotionValue(t);
                        if (e && !1 !== this.constraints) {
                            let i = e.get();
                            n[t] = function(t, e) {
                                let i = .5,
                                    n = iB(t),
                                    r = iB(e);
                                return r > n ? i = x(e.min, e.max - n, t.min) : n > r && (i = x(t.min, t.max - r, e.min)), tE(0, 1, i)
                            }({
                                min: i,
                                max: i
                            }, this.constraints[t])
                        }
                    });
                    let {
                        transformTemplate: r
                    } = this.visualElement.getProps();
                    this.visualElement.current.style.transform = r ? r({}, "") : "none", i.root && i.root.updateScroll(), i.updateLayout(), this.resolveConstraints(), iY(e => {
                        if (!no(e, t, null)) return;
                        let i = this.getAxisMotionValue(e),
                            {
                                min: r,
                                max: s
                            } = this.constraints[e];
                        i.set(eR(r, s, n[e]))
                    })
                }
                addListeners() {
                    if (!this.visualElement.current) return;
                    nr.set(this.visualElement, this);
                    let t = iD(this.visualElement.current, "pointerdown", t => {
                            let {
                                drag: e,
                                dragListener: i = !0
                            } = this.getProps();
                            e && i && this.start(t)
                        }),
                        e = () => {
                            let {
                                dragConstraints: t
                            } = this.getProps();
                            i2(t) && t.current && (this.constraints = this.resolveRefConstraints())
                        },
                        {
                            projection: i
                        } = this.visualElement,
                        n = i.addEventListener("measure", e);
                    i && !i.layout && (i.root && i.root.updateScroll(), i.updateLayout()), X.read(e);
                    let r = iR(window, "resize", () => this.scalePositionWithinConstraints()),
                        s = i.addEventListener("didUpdate", ({
                            delta: t,
                            hasLayoutChanged: e
                        }) => {
                            this.isDragging && e && (iY(e => {
                                let i = this.getAxisMotionValue(e);
                                i && (this.originPoint[e] += t[e].translate, i.set(i.get() + t[e].translate))
                            }), this.visualElement.render())
                        });
                    return () => {
                        r(), t(), n(), s && s()
                    }
                }
                getProps() {
                    let t = this.visualElement.getProps(),
                        {
                            drag: e = !1,
                            dragDirectionLock: i = !1,
                            dragPropagation: n = !1,
                            dragConstraints: r = !1,
                            dragElastic: s = .35,
                            dragMomentum: o = !0
                        } = t;
                    return {
                        ...t,
                        drag: e,
                        dragDirectionLock: i,
                        dragPropagation: n,
                        dragConstraints: r,
                        dragElastic: s,
                        dragMomentum: o
                    }
                }
            }

            function no(t, e, i) {
                return (!0 === e || e === t) && (null === i || i === t)
            }
            class na extends iA {
                constructor(t) {
                    super(t), this.removeGroupControls = F, this.removeListeners = F, this.controls = new ns(t)
                }
                mount() {
                    let {
                        dragControls: t
                    } = this.node.getProps();
                    t && (this.removeGroupControls = t.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || F
                }
                unmount() {
                    this.removeGroupControls(), this.removeListeners()
                }
            }
            let nl = t => (e, i) => {
                t && X.postRender(() => t(e, i))
            };
            class nu extends iA {
                constructor() {
                    super(...arguments), this.removePointerDownListener = F
                }
                onPointerDown(t) {
                    this.session = new i3(t, this.createPanHandlers(), {
                        transformPagePoint: this.node.getTransformPagePoint()
                    })
                }
                createPanHandlers() {
                    let {
                        onPanSessionStart: t,
                        onPanStart: e,
                        onPan: i,
                        onPanEnd: n
                    } = this.node.getProps();
                    return {
                        onSessionStart: nl(t),
                        onStart: nl(e),
                        onMove: i,
                        onEnd: (t, e) => {
                            delete this.session, n && X.postRender(() => n(t, e))
                        }
                    }
                }
                mount() {
                    this.removePointerDownListener = iD(this.node.current, "pointerdown", t => this.onPointerDown(t))
                }
                update() {
                    this.session && this.session.updateHandlers(this.createPanHandlers())
                }
                unmount() {
                    this.removePointerDownListener(), this.session && this.session.end()
                }
            }
            var nh, nd, nc = i(95155),
                np = i(12115),
                nf = i(85087),
                nm = i(64710);
            let ng = (0, np.createContext)({}),
                {
                    schedule: nv,
                    cancel: ny
                } = _(queueMicrotask, !1),
                nx = {
                    hasAnimatedSinceResize: !0,
                    hasEverUpdated: !1
                };

            function nw(t, e) {
                return e.max === e.min ? 0 : t / (e.max - e.min) * 100
            }
            let nT = {
                    correct: (t, e) => {
                        if (!e.target) return t;
                        if ("string" == typeof t) {
                            if (!tU.test(t)) return t;
                            t = parseFloat(t)
                        }
                        let i = nw(t, e.target.x),
                            n = nw(t, e.target.y);
                        return `${i}% ${n}%`
                    }
                },
                nP = {};
            class nb extends np.Component {
                componentDidMount() {
                    let {
                        visualElement: t,
                        layoutGroup: e,
                        switchLayoutGroup: i,
                        layoutId: n
                    } = this.props, {
                        projection: r
                    } = t;
                    ! function(t) {
                        for (let e in t) nP[e] = t[e], em(e) && (nP[e].isCSSVariable = !0)
                    }(nA), r && (e.group && e.group.add(r), i && i.register && n && i.register(r), r.root.didUpdate(), r.addEventListener("animationComplete", () => {
                        this.safeToRemove()
                    }), r.setOptions({
                        ...r.options,
                        onExitComplete: () => this.safeToRemove()
                    })), nx.hasEverUpdated = !0
                }
                getSnapshotBeforeUpdate(t) {
                    let {
                        layoutDependency: e,
                        visualElement: i,
                        drag: n,
                        isPresent: r
                    } = this.props, s = i.projection;
                    return s && (s.isPresent = r, n || t.layoutDependency !== e || void 0 === e || t.isPresent !== r ? s.willUpdate() : this.safeToRemove(), t.isPresent === r || (r ? s.promote() : s.relegate() || X.postRender(() => {
                        let t = s.getStack();
                        t && t.members.length || this.safeToRemove()
                    }))), null
                }
                componentDidUpdate() {
                    let {
                        projection: t
                    } = this.props.visualElement;
                    t && (t.root.didUpdate(), nv.postRender(() => {
                        !t.currentAnimation && t.isLead() && this.safeToRemove()
                    }))
                }
                componentWillUnmount() {
                    let {
                        visualElement: t,
                        layoutGroup: e,
                        switchLayoutGroup: i
                    } = this.props, {
                        projection: n
                    } = t;
                    n && (n.scheduleCheckAfterUnmount(), e && e.group && e.group.remove(n), i && i.deregister && i.deregister(n))
                }
                safeToRemove() {
                    let {
                        safeToRemove: t
                    } = this.props;
                    t && t()
                }
                render() {
                    return null
                }
            }

            function nE(t) {
                let [e, i] = (0, nf.xQ)(), n = (0, np.useContext)(nm.L);
                return (0, nc.jsx)(nb, {
                    ...t,
                    layoutGroup: n,
                    switchLayoutGroup: (0, np.useContext)(ng),
                    isPresent: e,
                    safeToRemove: i
                })
            }
            let nA = {
                    borderRadius: {
                        ...nT,
                        applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]
                    },
                    borderTopLeftRadius: nT,
                    borderTopRightRadius: nT,
                    borderBottomLeftRadius: nT,
                    borderBottomRightRadius: nT,
                    boxShadow: {
                        correct: (t, {
                            treeScale: e,
                            projectionDelta: i
                        }) => {
                            let n = t0.parse(t);
                            if (n.length > 5) return t;
                            let r = t0.createTransformer(t),
                                s = +("number" != typeof n[0]),
                                o = i.x.scale * e.x,
                                a = i.y.scale * e.y;
                            n[0 + s] /= o, n[1 + s] /= a;
                            let l = eR(o, a, .5);
                            return "number" == typeof n[2 + s] && (n[2 + s] /= l), "number" == typeof n[3 + s] && (n[3 + s] /= l), r(n)
                        }
                    }
                },
                nS = (t, e) => t.depth - e.depth;
            class nC {
                constructor() {
                    this.children = [], this.isDirty = !1
                }
                add(t) {
                    tt(this.children, t), this.isDirty = !0
                }
                remove(t) {
                    te(this.children, t), this.isDirty = !0
                }
                forEach(t) {
                    this.isDirty && this.children.sort(nS), this.isDirty = !1, this.children.forEach(t)
                }
            }

            function nM(t) {
                let e = ta(t) ? t.get() : t;
                return H(e) ? e.toValue() : e
            }
            let nR = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"],
                nV = nR.length,
                nk = t => "string" == typeof t ? parseFloat(t) : t,
                nD = t => "number" == typeof t || tU.test(t);

            function nL(t, e) {
                return void 0 !== t[e] ? t[e] : t.borderRadius
            }
            let nB = nI(0, .5, tT),
                nj = nI(.5, .95, F);

            function nI(t, e, i) {
                return n => n < t ? 0 : n > e ? 1 : i(x(t, e, n))
            }

            function nF(t, e) {
                t.min = e.min, t.max = e.max
            }

            function nN(t, e) {
                nF(t.x, e.x), nF(t.y, e.y)
            }

            function nO(t, e) {
                t.translate = e.translate, t.scale = e.scale, t.originPoint = e.originPoint, t.origin = e.origin
            }

            function nU(t, e, i, n, r) {
                return t -= e, t = n + 1 / i * (t - n), void 0 !== r && (t = n + 1 / r * (t - n)), t
            }

            function n$(t, e, [i, n, r], s, o) {
                ! function(t, e = 0, i = 1, n = .5, r, s = t, o = t) {
                    if (tO.test(e) && (e = parseFloat(e), e = eR(o.min, o.max, e / 100) - o.min), "number" != typeof e) return;
                    let a = eR(s.min, s.max, n);
                    t === s && (a -= e), t.min = nU(t.min, e, i, a, r), t.max = nU(t.max, e, i, a, r)
                }(t, e[i], e[n], e[r], e.scale, s, o)
            }
            let nH = ["x", "scaleX", "originX"],
                nz = ["y", "scaleY", "originY"];

            function nY(t, e, i, n) {
                n$(t.x, e, nH, i ? i.x : void 0, n ? n.x : void 0), n$(t.y, e, nz, i ? i.y : void 0, n ? n.y : void 0)
            }

            function nW(t) {
                return 0 === t.translate && 1 === t.scale
            }

            function nK(t) {
                return nW(t.x) && nW(t.y)
            }

            function n_(t, e) {
                return t.min === e.min && t.max === e.max
            }

            function nX(t, e) {
                return Math.round(t.min) === Math.round(e.min) && Math.round(t.max) === Math.round(e.max)
            }

            function nq(t, e) {
                return nX(t.x, e.x) && nX(t.y, e.y)
            }

            function nJ(t) {
                return iB(t.x) / iB(t.y)
            }

            function nQ(t, e) {
                return t.translate === e.translate && t.scale === e.scale && t.originPoint === e.originPoint
            }
            class nG {
                constructor() {
                    this.members = []
                }
                add(t) {
                    tt(this.members, t), t.scheduleRender()
                }
                remove(t) {
                    if (te(this.members, t), t === this.prevLead && (this.prevLead = void 0), t === this.lead) {
                        let t = this.members[this.members.length - 1];
                        t && this.promote(t)
                    }
                }
                relegate(t) {
                    let e;
                    let i = this.members.findIndex(e => t === e);
                    if (0 === i) return !1;
                    for (let t = i; t >= 0; t--) {
                        let i = this.members[t];
                        if (!1 !== i.isPresent) {
                            e = i;
                            break
                        }
                    }
                    return !!e && (this.promote(e), !0)
                }
                promote(t, e) {
                    let i = this.lead;
                    if (t !== i && (this.prevLead = i, this.lead = t, t.show(), i)) {
                        i.instance && i.scheduleRender(), t.scheduleRender(), t.resumeFrom = i, e && (t.resumeFrom.preserveOpacity = !0), i.snapshot && (t.snapshot = i.snapshot, t.snapshot.latestValues = i.animationValues || i.latestValues), t.root && t.root.isUpdating && (t.isLayoutDirty = !0);
                        let {
                            crossfade: n
                        } = t.options;
                        !1 === n && i.hide()
                    }
                }
                exitAnimationComplete() {
                    this.members.forEach(t => {
                        let {
                            options: e,
                            resumingFrom: i
                        } = t;
                        e.onExitComplete && e.onExitComplete(), i && i.options.onExitComplete && i.options.onExitComplete()
                    })
                }
                scheduleRender() {
                    this.members.forEach(t => {
                        t.instance && t.scheduleRender(!1)
                    })
                }
                removeLeadSnapshot() {
                    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
                }
            }
            let nZ = {
                    nodes: 0,
                    calculatedTargetDeltas: 0,
                    calculatedProjections: 0
                },
                n0 = ["", "X", "Y", "Z"],
                n1 = {
                    visibility: "hidden"
                },
                n2 = 0;

            function n5(t, e, i, n) {
                let {
                    latestValues: r
                } = e;
                r[t] && (i[t] = r[t], e.setStaticValue(t, 0), n && (n[t] = 0))
            }

            function n3({
                attachResizeListener: t,
                defaultParent: e,
                measureScroll: i,
                checkIsScrollRoot: n,
                resetTransform: r
            }) {
                return class {
                    constructor(t = {}, i = null == e ? void 0 : e()) {
                        this.id = n2++, this.animationId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = {
                            x: 1,
                            y: 1
                        }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
                            this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots())
                        }, this.updateProjection = () => {
                            this.projectionUpdateScheduled = !1, K.value && (nZ.nodes = nZ.calculatedTargetDeltas = nZ.calculatedProjections = 0), this.nodes.forEach(n6), this.nodes.forEach(rr), this.nodes.forEach(rs), this.nodes.forEach(n7), K.addProjectionMetrics && K.addProjectionMetrics(nZ)
                        }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = t, this.root = i ? i.root || i : this, this.path = i ? [...i.path, i] : [], this.parent = i, this.depth = i ? i.depth + 1 : 0;
                        for (let t = 0; t < this.path.length; t++) this.path[t].shouldResetTransform = !0;
                        this.root === this && (this.nodes = new nC)
                    }
                    addEventListener(t, e) {
                        return this.eventHandlers.has(t) || this.eventHandlers.set(t, new ti), this.eventHandlers.get(t).add(e)
                    }
                    notifyListeners(t, ...e) {
                        let i = this.eventHandlers.get(t);
                        i && i.notify(...e)
                    }
                    hasListeners(t) {
                        return this.eventHandlers.has(t)
                    }
                    mount(e, i = this.root.hasTreeAnimated) {
                        if (this.instance) return;
                        this.isSVG = e instanceof SVGElement && "svg" !== e.tagName, this.instance = e;
                        let {
                            layoutId: n,
                            layout: r,
                            visualElement: s
                        } = this.options;
                        if (s && !s.current && s.mount(e), this.root.nodes.add(this), this.parent && this.parent.children.add(this), i && (r || n) && (this.isLayoutDirty = !0), t) {
                            let i;
                            let n = () => this.root.updateBlockedByResize = !1;
                            t(e, () => {
                                this.root.updateBlockedByResize = !0, i && i(), i = function(t, e) {
                                    let i = Z.now(),
                                        n = ({
                                            timestamp: r
                                        }) => {
                                            let s = r - i;
                                            s >= 250 && (q(n), t(s - e))
                                        };
                                    return X.read(n, !0), () => q(n)
                                }(n, 250), nx.hasAnimatedSinceResize && (nx.hasAnimatedSinceResize = !1, this.nodes.forEach(rn))
                            })
                        }
                        n && this.root.registerSharedNode(n, this), !1 !== this.options.animate && s && (n || r) && this.addEventListener("didUpdate", ({
                            delta: t,
                            hasLayoutChanged: e,
                            hasRelativeLayoutChanged: i,
                            layout: n
                        }) => {
                            if (this.isTreeAnimationBlocked()) {
                                this.target = void 0, this.relativeTarget = void 0;
                                return
                            }
                            let r = this.options.transition || s.getDefaultTransition() || rd,
                                {
                                    onLayoutAnimationStart: o,
                                    onLayoutAnimationComplete: a
                                } = s.getProps(),
                                l = !this.targetLayout || !nq(this.targetLayout, n),
                                u = !e && i;
                            if (this.options.layoutRoot || this.resumeFrom || u || e && (l || !this.currentAnimation)) {
                                this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(t, u);
                                let e = {
                                    ...c(r, "layout"),
                                    onPlay: o,
                                    onComplete: a
                                };
                                (s.shouldReduceMotion || this.options.layoutRoot) && (e.delay = 0, e.type = !1), this.startAnimation(e)
                            } else e || rn(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
                            this.targetLayout = n
                        })
                    }
                    unmount() {
                        this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
                        let t = this.getStack();
                        t && t.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, q(this.updateProjection)
                    }
                    blockUpdate() {
                        this.updateManuallyBlocked = !0
                    }
                    unblockUpdate() {
                        this.updateManuallyBlocked = !1
                    }
                    isUpdateBlocked() {
                        return this.updateManuallyBlocked || this.updateBlockedByResize
                    }
                    isTreeAnimationBlocked() {
                        return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1
                    }
                    startUpdate() {
                        !this.isUpdateBlocked() && (this.isUpdating = !0, this.nodes && this.nodes.forEach(ro), this.animationId++)
                    }
                    getTransformTemplate() {
                        let {
                            visualElement: t
                        } = this.options;
                        return t && t.getProps().transformTemplate
                    }
                    willUpdate(t = !0) {
                        if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
                            this.options.onExitComplete && this.options.onExitComplete();
                            return
                        }
                        if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && function t(e) {
                                if (e.hasCheckedOptimisedAppear = !0, e.root === e) return;
                                let {
                                    visualElement: i
                                } = e.options;
                                if (!i) return;
                                let n = i.props[th];
                                if (window.MotionHasOptimisedAnimation(n, "transform")) {
                                    let {
                                        layout: t,
                                        layoutId: i
                                    } = e.options;
                                    window.MotionCancelOptimisedAnimation(n, "transform", X, !(t || i))
                                }
                                let {
                                    parent: r
                                } = e;
                                r && !r.hasCheckedOptimisedAppear && t(r)
                            }(this), this.root.isUpdating || this.root.startUpdate(), this.isLayoutDirty) return;
                        this.isLayoutDirty = !0;
                        for (let t = 0; t < this.path.length; t++) {
                            let e = this.path[t];
                            e.shouldResetTransform = !0, e.updateScroll("snapshot"), e.options.layoutRoot && e.willUpdate(!1)
                        }
                        let {
                            layoutId: e,
                            layout: i
                        } = this.options;
                        if (void 0 === e && !i) return;
                        let n = this.getTransformTemplate();
                        this.prevTransformTemplateValue = n ? n(this.latestValues, "") : void 0, this.updateSnapshot(), t && this.notifyListeners("willUpdate")
                    }
                    update() {
                        if (this.updateScheduled = !1, this.isUpdateBlocked()) {
                            this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(rt);
                            return
                        }
                        this.isUpdating || this.nodes.forEach(re), this.isUpdating = !1, this.nodes.forEach(ri), this.nodes.forEach(n4), this.nodes.forEach(n8), this.clearAllSnapshots();
                        let t = Z.now();
                        J.delta = tE(0, 1e3 / 60, t - J.timestamp), J.timestamp = t, J.isProcessing = !0, Q.update.process(J), Q.preRender.process(J), Q.render.process(J), J.isProcessing = !1
                    }
                    didUpdate() {
                        this.updateScheduled || (this.updateScheduled = !0, nv.read(this.scheduleUpdate))
                    }
                    clearAllSnapshots() {
                        this.nodes.forEach(n9), this.sharedNodes.forEach(ra)
                    }
                    scheduleUpdateProjection() {
                        this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, X.preRender(this.updateProjection, !1, !0))
                    }
                    scheduleCheckAfterUnmount() {
                        X.postRender(() => {
                            this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
                        })
                    }
                    updateSnapshot() {
                        this.snapshot || !this.instance || (this.snapshot = this.measure(), !this.snapshot || iB(this.snapshot.measuredBox.x) || iB(this.snapshot.measuredBox.y) || (this.snapshot = void 0))
                    }
                    updateLayout() {
                        if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return;
                        if (this.resumeFrom && !this.resumeFrom.instance)
                            for (let t = 0; t < this.path.length; t++) this.path[t].updateScroll();
                        let t = this.layout;
                        this.layout = this.measure(!1), this.layoutCorrected = iz(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
                        let {
                            visualElement: e
                        } = this.options;
                        e && e.notify("LayoutMeasure", this.layout.layoutBox, t ? t.layoutBox : void 0)
                    }
                    updateScroll(t = "measure") {
                        let e = !!(this.options.layoutScroll && this.instance);
                        if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === t && (e = !1), e) {
                            let e = n(this.instance);
                            this.scroll = {
                                animationId: this.root.animationId,
                                phase: t,
                                isRoot: e,
                                offset: i(this.instance),
                                wasRoot: this.scroll ? this.scroll.isRoot : e
                            }
                        }
                    }
                    resetTransform() {
                        if (!r) return;
                        let t = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout,
                            e = this.projectionDelta && !nK(this.projectionDelta),
                            i = this.getTransformTemplate(),
                            n = i ? i(this.latestValues, "") : void 0,
                            s = n !== this.prevTransformTemplateValue;
                        t && (e || i_(this.latestValues) || s) && (r(this.instance, n), this.shouldResetTransform = !1, this.scheduleRender())
                    }
                    measure(t = !0) {
                        var e;
                        let i = this.measurePageBox(),
                            n = this.removeElementScroll(i);
                        return t && (n = this.removeTransform(n)), rf((e = n).x), rf(e.y), {
                            animationId: this.root.animationId,
                            measuredBox: i,
                            layoutBox: n,
                            latestValues: {},
                            source: this.id
                        }
                    }
                    measurePageBox() {
                        var t;
                        let {
                            visualElement: e
                        } = this.options;
                        if (!e) return iz();
                        let i = e.measureViewportBox();
                        if (!((null === (t = this.scroll) || void 0 === t ? void 0 : t.wasRoot) || this.path.some(rg))) {
                            let {
                                scroll: t
                            } = this.root;
                            t && (iG(i.x, t.offset.x), iG(i.y, t.offset.y))
                        }
                        return i
                    }
                    removeElementScroll(t) {
                        var e;
                        let i = iz();
                        if (nN(i, t), null === (e = this.scroll) || void 0 === e ? void 0 : e.wasRoot) return i;
                        for (let e = 0; e < this.path.length; e++) {
                            let n = this.path[e],
                                {
                                    scroll: r,
                                    options: s
                                } = n;
                            n !== this.root && r && s.layoutScroll && (r.wasRoot && nN(i, t), iG(i.x, r.offset.x), iG(i.y, r.offset.y))
                        }
                        return i
                    }
                    applyTransform(t, e = !1) {
                        let i = iz();
                        nN(i, t);
                        for (let t = 0; t < this.path.length; t++) {
                            let n = this.path[t];
                            !e && n.options.layoutScroll && n.scroll && n !== n.root && i0(i, {
                                x: -n.scroll.offset.x,
                                y: -n.scroll.offset.y
                            }), i_(n.latestValues) && i0(i, n.latestValues)
                        }
                        return i_(this.latestValues) && i0(i, this.latestValues), i
                    }
                    removeTransform(t) {
                        let e = iz();
                        nN(e, t);
                        for (let t = 0; t < this.path.length; t++) {
                            let i = this.path[t];
                            if (!i.instance || !i_(i.latestValues)) continue;
                            iK(i.latestValues) && i.updateSnapshot();
                            let n = iz();
                            nN(n, i.measurePageBox()), nY(e, i.latestValues, i.snapshot ? i.snapshot.layoutBox : void 0, n)
                        }
                        return i_(this.latestValues) && nY(e, this.latestValues), e
                    }
                    setTargetDelta(t) {
                        this.targetDelta = t, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0
                    }
                    setOptions(t) {
                        this.options = {
                            ...this.options,
                            ...t,
                            crossfade: void 0 === t.crossfade || t.crossfade
                        }
                    }
                    clearMeasurements() {
                        this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1
                    }
                    forceRelativeParentToResolveTarget() {
                        this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== J.timestamp && this.relativeParent.resolveTargetDelta(!0)
                    }
                    resolveTargetDelta(t = !1) {
                        var e, i, n, r;
                        let s = this.getLead();
                        this.isProjectionDirty || (this.isProjectionDirty = s.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = s.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = s.isSharedProjectionDirty);
                        let o = !!this.resumingFrom || this !== s;
                        if (!(t || o && this.isSharedProjectionDirty || this.isProjectionDirty || (null === (e = this.parent) || void 0 === e ? void 0 : e.isProjectionDirty) || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize)) return;
                        let {
                            layout: a,
                            layoutId: l
                        } = this.options;
                        if (this.layout && (a || l)) {
                            if (this.resolvedRelativeTargetAt = J.timestamp, !this.targetDelta && !this.relativeTarget) {
                                let t = this.getClosestProjectingParent();
                                t && t.layout && 1 !== this.animationProgress ? (this.relativeParent = t, this.forceRelativeParentToResolveTarget(), this.relativeTarget = iz(), this.relativeTargetOrigin = iz(), iO(this.relativeTargetOrigin, this.layout.layoutBox, t.layout.layoutBox), nN(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                            }
                            if (this.relativeTarget || this.targetDelta) {
                                if ((this.target || (this.target = iz(), this.targetWithTransforms = iz()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) ? (this.forceRelativeParentToResolveTarget(), i = this.target, n = this.relativeTarget, r = this.relativeParent.target, iF(i.x, n.x, r.x), iF(i.y, n.y, r.y)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : nN(this.target, this.layout.layoutBox), iQ(this.target, this.targetDelta)) : nN(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) {
                                    this.attemptToResolveRelativeTarget = !1;
                                    let t = this.getClosestProjectingParent();
                                    t && !!t.resumingFrom == !!this.resumingFrom && !t.options.layoutScroll && t.target && 1 !== this.animationProgress ? (this.relativeParent = t, this.forceRelativeParentToResolveTarget(), this.relativeTarget = iz(), this.relativeTargetOrigin = iz(), iO(this.relativeTargetOrigin, this.target, t.target), nN(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                                }
                                K.value && nZ.calculatedTargetDeltas++
                            }
                        }
                    }
                    getClosestProjectingParent() {
                        return !this.parent || iK(this.parent.latestValues) || iX(this.parent.latestValues) ? void 0 : this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent()
                    }
                    isProjecting() {
                        return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout)
                    }
                    calcProjection() {
                        var t;
                        let e = this.getLead(),
                            i = !!this.resumingFrom || this !== e,
                            n = !0;
                        if ((this.isProjectionDirty || (null === (t = this.parent) || void 0 === t ? void 0 : t.isProjectionDirty)) && (n = !1), i && (this.isSharedProjectionDirty || this.isTransformDirty) && (n = !1), this.resolvedRelativeTargetAt === J.timestamp && (n = !1), n) return;
                        let {
                            layout: r,
                            layoutId: s
                        } = this.options;
                        if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(r || s)) return;
                        nN(this.layoutCorrected, this.layout.layoutBox);
                        let o = this.treeScale.x,
                            a = this.treeScale.y;
                        ! function(t, e, i, n = !1) {
                            let r, s;
                            let o = i.length;
                            if (o) {
                                e.x = e.y = 1;
                                for (let a = 0; a < o; a++) {
                                    s = (r = i[a]).projectionDelta;
                                    let {
                                        visualElement: o
                                    } = r.options;
                                    (!o || !o.props.style || "contents" !== o.props.style.display) && (n && r.options.layoutScroll && r.scroll && r !== r.root && i0(t, {
                                        x: -r.scroll.offset.x,
                                        y: -r.scroll.offset.y
                                    }), s && (e.x *= s.x.scale, e.y *= s.y.scale, iQ(t, s)), n && i_(r.latestValues) && i0(t, r.latestValues))
                                }
                                e.x < 1.0000000000001 && e.x > .999999999999 && (e.x = 1), e.y < 1.0000000000001 && e.y > .999999999999 && (e.y = 1)
                            }
                        }(this.layoutCorrected, this.treeScale, this.path, i), e.layout && !e.target && (1 !== this.treeScale.x || 1 !== this.treeScale.y) && (e.target = e.layout.layoutBox, e.targetWithTransforms = iz());
                        let {
                            target: l
                        } = e;
                        if (!l) {
                            this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
                            return
                        }
                        this.projectionDelta && this.prevProjectionDelta ? (nO(this.prevProjectionDelta.x, this.projectionDelta.x), nO(this.prevProjectionDelta.y, this.projectionDelta.y)) : this.createProjectionDeltas(), iI(this.projectionDelta, this.layoutCorrected, l, this.latestValues), this.treeScale.x === o && this.treeScale.y === a && nQ(this.projectionDelta.x, this.prevProjectionDelta.x) && nQ(this.projectionDelta.y, this.prevProjectionDelta.y) || (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", l)), K.value && nZ.calculatedProjections++
                    }
                    hide() {
                        this.isVisible = !1
                    }
                    show() {
                        this.isVisible = !0
                    }
                    scheduleRender(t = !0) {
                        var e;
                        if (null === (e = this.options.visualElement) || void 0 === e || e.scheduleRender(), t) {
                            let t = this.getStack();
                            t && t.scheduleRender()
                        }
                        this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
                    }
                    createProjectionDeltas() {
                        this.prevProjectionDelta = i$(), this.projectionDelta = i$(), this.projectionDeltaWithTransform = i$()
                    }
                    setAnimationOrigin(t, e = !1) {
                        let i;
                        let n = this.snapshot,
                            r = n ? n.latestValues : {},
                            s = {
                                ...this.latestValues
                            },
                            o = i$();
                        this.relativeParent && this.relativeParent.options.layoutRoot || (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !e;
                        let a = iz(),
                            l = (n ? n.source : void 0) !== (this.layout ? this.layout.source : void 0),
                            u = this.getStack(),
                            h = !u || u.members.length <= 1,
                            d = !!(l && !h && !0 === this.options.crossfade && !this.path.some(rh));
                        this.animationProgress = 0, this.mixTargetDelta = e => {
                            let n = e / 1e3;
                            if (rl(o.x, t.x, n), rl(o.y, t.y, n), this.setTargetDelta(o), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {
                                var u, c, p, f, m, g;
                                if (iO(a, this.layout.layoutBox, this.relativeParent.layout.layoutBox), p = this.relativeTarget, f = this.relativeTargetOrigin, m = a, g = n, ru(p.x, f.x, m.x, g), ru(p.y, f.y, m.y, g), i && (u = this.relativeTarget, c = i, n_(u.x, c.x) && n_(u.y, c.y))) this.isProjectionDirty = !1;
                                i || (i = iz()), nN(i, this.relativeTarget)
                            }
                            l && (this.animationValues = s, function(t, e, i, n, r, s) {
                                r ? (t.opacity = eR(0, void 0 !== i.opacity ? i.opacity : 1, nB(n)), t.opacityExit = eR(void 0 !== e.opacity ? e.opacity : 1, 0, nj(n))) : s && (t.opacity = eR(void 0 !== e.opacity ? e.opacity : 1, void 0 !== i.opacity ? i.opacity : 1, n));
                                for (let r = 0; r < nV; r++) {
                                    let s = `border${nR[r]}Radius`,
                                        o = nL(e, s),
                                        a = nL(i, s);
                                    (void 0 !== o || void 0 !== a) && (o || (o = 0), a || (a = 0), 0 === o || 0 === a || nD(o) === nD(a) ? (t[s] = Math.max(eR(nk(o), nk(a), n), 0), (tO.test(a) || tO.test(o)) && (t[s] += "%")) : t[s] = a)
                                }(e.rotate || i.rotate) && (t.rotate = eR(e.rotate || 0, i.rotate || 0, n))
                            }(s, r, this.latestValues, n, d, h)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = n
                        }, this.mixTargetDelta(1e3 * !!this.options.layoutRoot)
                    }
                    startAnimation(t) {
                        this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (q(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = X.update(() => {
                            nx.hasAnimatedSinceResize = !0, eM.layout++, this.currentAnimation = function(t, e, i) {
                                let n = ta(0) ? 0 : to(t);
                                return n.start(id("", n, 1e3, i)), n.animation
                            }(0, 0, {
                                ...t,
                                onUpdate: e => {
                                    this.mixTargetDelta(e), t.onUpdate && t.onUpdate(e)
                                },
                                onStop: () => {
                                    eM.layout--
                                },
                                onComplete: () => {
                                    eM.layout--, t.onComplete && t.onComplete(), this.completeAnimation()
                                }
                            }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0
                        })
                    }
                    completeAnimation() {
                        this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
                        let t = this.getStack();
                        t && t.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete")
                    }
                    finishAnimation() {
                        this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(1e3), this.currentAnimation.stop()), this.completeAnimation()
                    }
                    applyTransformsToTarget() {
                        let t = this.getLead(),
                            {
                                targetWithTransforms: e,
                                target: i,
                                layout: n,
                                latestValues: r
                            } = t;
                        if (e && i && n) {
                            if (this !== t && this.layout && n && rm(this.options.animationType, this.layout.layoutBox, n.layoutBox)) {
                                i = this.target || iz();
                                let e = iB(this.layout.layoutBox.x);
                                i.x.min = t.target.x.min, i.x.max = i.x.min + e;
                                let n = iB(this.layout.layoutBox.y);
                                i.y.min = t.target.y.min, i.y.max = i.y.min + n
                            }
                            nN(e, i), i0(e, r), iI(this.projectionDeltaWithTransform, this.layoutCorrected, e, r)
                        }
                    }
                    registerSharedNode(t, e) {
                        this.sharedNodes.has(t) || this.sharedNodes.set(t, new nG), this.sharedNodes.get(t).add(e);
                        let i = e.options.initialPromotionConfig;
                        e.promote({
                            transition: i ? i.transition : void 0,
                            preserveFollowOpacity: i && i.shouldPreserveFollowOpacity ? i.shouldPreserveFollowOpacity(e) : void 0
                        })
                    }
                    isLead() {
                        let t = this.getStack();
                        return !t || t.lead === this
                    }
                    getLead() {
                        var t;
                        let {
                            layoutId: e
                        } = this.options;
                        return e && (null === (t = this.getStack()) || void 0 === t ? void 0 : t.lead) || this
                    }
                    getPrevLead() {
                        var t;
                        let {
                            layoutId: e
                        } = this.options;
                        return e ? null === (t = this.getStack()) || void 0 === t ? void 0 : t.prevLead : void 0
                    }
                    getStack() {
                        let {
                            layoutId: t
                        } = this.options;
                        if (t) return this.root.sharedNodes.get(t)
                    }
                    promote({
                        needsReset: t,
                        transition: e,
                        preserveFollowOpacity: i
                    } = {}) {
                        let n = this.getStack();
                        n && n.promote(this, i), t && (this.projectionDelta = void 0, this.needsReset = !0), e && this.setOptions({
                            transition: e
                        })
                    }
                    relegate() {
                        let t = this.getStack();
                        return !!t && t.relegate(this)
                    }
                    resetSkewAndRotation() {
                        let {
                            visualElement: t
                        } = this.options;
                        if (!t) return;
                        let e = !1,
                            {
                                latestValues: i
                            } = t;
                        if ((i.z || i.rotate || i.rotateX || i.rotateY || i.rotateZ || i.skewX || i.skewY) && (e = !0), !e) return;
                        let n = {};
                        i.z && n5("z", t, n, this.animationValues);
                        for (let e = 0; e < n0.length; e++) n5(`rotate${n0[e]}`, t, n, this.animationValues), n5(`skew${n0[e]}`, t, n, this.animationValues);
                        for (let e in t.render(), n) t.setStaticValue(e, n[e]), this.animationValues && (this.animationValues[e] = n[e]);
                        t.scheduleRender()
                    }
                    getProjectionStyles(t) {
                        var e, i;
                        if (!this.instance || this.isSVG) return;
                        if (!this.isVisible) return n1;
                        let n = {
                                visibility: ""
                            },
                            r = this.getTransformTemplate();
                        if (this.needsReset) return this.needsReset = !1, n.opacity = "", n.pointerEvents = nM(null == t ? void 0 : t.pointerEvents) || "", n.transform = r ? r(this.latestValues, "") : "none", n;
                        let s = this.getLead();
                        if (!this.projectionDelta || !this.layout || !s.target) {
                            let e = {};
                            return this.options.layoutId && (e.opacity = void 0 !== this.latestValues.opacity ? this.latestValues.opacity : 1, e.pointerEvents = nM(null == t ? void 0 : t.pointerEvents) || ""), this.hasProjected && !i_(this.latestValues) && (e.transform = r ? r({}, "") : "none", this.hasProjected = !1), e
                        }
                        let o = s.animationValues || s.latestValues;
                        this.applyTransformsToTarget(), n.transform = function(t, e, i) {
                            let n = "",
                                r = t.x.translate / e.x,
                                s = t.y.translate / e.y,
                                o = (null == i ? void 0 : i.z) || 0;
                            if ((r || s || o) && (n = `translate3d(${r}px, ${s}px, ${o}px) `), (1 !== e.x || 1 !== e.y) && (n += `scale(${1/e.x}, ${1/e.y}) `), i) {
                                let {
                                    transformPerspective: t,
                                    rotate: e,
                                    rotateX: r,
                                    rotateY: s,
                                    skewX: o,
                                    skewY: a
                                } = i;
                                t && (n = `perspective(${t}px) ${n}`), e && (n += `rotate(${e}deg) `), r && (n += `rotateX(${r}deg) `), s && (n += `rotateY(${s}deg) `), o && (n += `skewX(${o}deg) `), a && (n += `skewY(${a}deg) `)
                            }
                            let a = t.x.scale * e.x,
                                l = t.y.scale * e.y;
                            return (1 !== a || 1 !== l) && (n += `scale(${a}, ${l})`), n || "none"
                        }(this.projectionDeltaWithTransform, this.treeScale, o), r && (n.transform = r(o, n.transform));
                        let {
                            x: a,
                            y: l
                        } = this.projectionDelta;
                        for (let t in n.transformOrigin = `${100*a.origin}% ${100*l.origin}% 0`, s.animationValues ? n.opacity = s === this ? null !== (i = null !== (e = o.opacity) && void 0 !== e ? e : this.latestValues.opacity) && void 0 !== i ? i : 1 : this.preserveOpacity ? this.latestValues.opacity : o.opacityExit : n.opacity = s === this ? void 0 !== o.opacity ? o.opacity : "" : void 0 !== o.opacityExit ? o.opacityExit : 0, nP) {
                            if (void 0 === o[t]) continue;
                            let {
                                correct: e,
                                applyTo: i,
                                isCSSVariable: r
                            } = nP[t], a = "none" === n.transform ? o[t] : e(o[t], s);
                            if (i) {
                                let t = i.length;
                                for (let e = 0; e < t; e++) n[i[e]] = a
                            } else r ? this.options.visualElement.renderState.vars[t] = a : n[t] = a
                        }
                        return this.options.layoutId && (n.pointerEvents = s === this ? nM(null == t ? void 0 : t.pointerEvents) || "" : "none"), n
                    }
                    clearSnapshot() {
                        this.resumeFrom = this.snapshot = void 0
                    }
                    resetTree() {
                        this.root.nodes.forEach(t => {
                            var e;
                            return null === (e = t.currentAnimation) || void 0 === e ? void 0 : e.stop()
                        }), this.root.nodes.forEach(rt), this.root.sharedNodes.clear()
                    }
                }
            }

            function n4(t) {
                t.updateLayout()
            }

            function n8(t) {
                var e;
                let i = (null === (e = t.resumeFrom) || void 0 === e ? void 0 : e.snapshot) || t.snapshot;
                if (t.isLead() && t.layout && i && t.hasListeners("didUpdate")) {
                    let {
                        layoutBox: e,
                        measuredBox: n
                    } = t.layout, {
                        animationType: r
                    } = t.options, s = i.source !== t.layout.source;
                    "size" === r ? iY(t => {
                        let n = s ? i.measuredBox[t] : i.layoutBox[t],
                            r = iB(n);
                        n.min = e[t].min, n.max = n.min + r
                    }) : rm(r, i.layoutBox, e) && iY(n => {
                        let r = s ? i.measuredBox[n] : i.layoutBox[n],
                            o = iB(e[n]);
                        r.max = r.min + o, t.relativeTarget && !t.currentAnimation && (t.isProjectionDirty = !0, t.relativeTarget[n].max = t.relativeTarget[n].min + o)
                    });
                    let o = i$();
                    iI(o, e, i.layoutBox);
                    let a = i$();
                    s ? iI(a, t.applyTransform(n, !0), i.measuredBox) : iI(a, e, i.layoutBox);
                    let l = !nK(o),
                        u = !1;
                    if (!t.resumeFrom) {
                        let n = t.getClosestProjectingParent();
                        if (n && !n.resumeFrom) {
                            let {
                                snapshot: r,
                                layout: s
                            } = n;
                            if (r && s) {
                                let o = iz();
                                iO(o, i.layoutBox, r.layoutBox);
                                let a = iz();
                                iO(a, e, s.layoutBox), nq(o, a) || (u = !0), n.options.layoutRoot && (t.relativeTarget = a, t.relativeTargetOrigin = o, t.relativeParent = n)
                            }
                        }
                    }
                    t.notifyListeners("didUpdate", {
                        layout: e,
                        snapshot: i,
                        delta: a,
                        layoutDelta: o,
                        hasLayoutChanged: l,
                        hasRelativeLayoutChanged: u
                    })
                } else if (t.isLead()) {
                    let {
                        onExitComplete: e
                    } = t.options;
                    e && e()
                }
                t.options.transition = void 0
            }

            function n6(t) {
                K.value && nZ.nodes++, t.parent && (t.isProjecting() || (t.isProjectionDirty = t.parent.isProjectionDirty), t.isSharedProjectionDirty || (t.isSharedProjectionDirty = !!(t.isProjectionDirty || t.parent.isProjectionDirty || t.parent.isSharedProjectionDirty)), t.isTransformDirty || (t.isTransformDirty = t.parent.isTransformDirty))
            }

            function n7(t) {
                t.isProjectionDirty = t.isSharedProjectionDirty = t.isTransformDirty = !1
            }

            function n9(t) {
                t.clearSnapshot()
            }

            function rt(t) {
                t.clearMeasurements()
            }

            function re(t) {
                t.isLayoutDirty = !1
            }

            function ri(t) {
                let {
                    visualElement: e
                } = t.options;
                e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"), t.resetTransform()
            }

            function rn(t) {
                t.finishAnimation(), t.targetDelta = t.relativeTarget = t.target = void 0, t.isProjectionDirty = !0
            }

            function rr(t) {
                t.resolveTargetDelta()
            }

            function rs(t) {
                t.calcProjection()
            }

            function ro(t) {
                t.resetSkewAndRotation()
            }

            function ra(t) {
                t.removeLeadSnapshot()
            }

            function rl(t, e, i) {
                t.translate = eR(e.translate, 0, i), t.scale = eR(e.scale, 1, i), t.origin = e.origin, t.originPoint = e.originPoint
            }

            function ru(t, e, i, n) {
                t.min = eR(e.min, i.min, n), t.max = eR(e.max, i.max, n)
            }

            function rh(t) {
                return t.animationValues && void 0 !== t.animationValues.opacityExit
            }
            let rd = {
                    duration: .45,
                    ease: [.4, 0, .1, 1]
                },
                rc = t => "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().includes(t),
                rp = rc("applewebkit/") && !rc("chrome/") ? Math.round : F;

            function rf(t) {
                t.min = rp(t.min), t.max = rp(t.max)
            }

            function rm(t, e, i) {
                return "position" === t || "preserve-aspect" === t && !(.2 >= Math.abs(nJ(e) - nJ(i)))
            }

            function rg(t) {
                var e;
                return t !== t.root && (null === (e = t.scroll) || void 0 === e ? void 0 : e.wasRoot)
            }
            let rv = n3({
                    attachResizeListener: (t, e) => iR(t, "resize", e),
                    measureScroll: () => ({
                        x: document.documentElement.scrollLeft || document.body.scrollLeft,
                        y: document.documentElement.scrollTop || document.body.scrollTop
                    }),
                    checkIsScrollRoot: () => !0
                }),
                ry = {
                    current: void 0
                },
                rx = n3({
                    measureScroll: t => ({
                        x: t.scrollLeft,
                        y: t.scrollTop
                    }),
                    defaultParent: () => {
                        if (!ry.current) {
                            let t = new rv({});
                            t.mount(window), t.setOptions({
                                layoutScroll: !0
                            }), ry.current = t
                        }
                        return ry.current
                    },
                    resetTransform: (t, e) => {
                        t.style.transform = void 0 !== e ? e : "none"
                    },
                    checkIsScrollRoot: t => "fixed" === window.getComputedStyle(t).position
                });

            function rw(t, e, i) {
                let {
                    props: n
                } = t;
                t.animationState && n.whileHover && t.animationState.setActive("whileHover", "Start" === i);
                let r = n["onHover" + i];
                r && X.postRender(() => r(e, iV(e)))
            }
            class rT extends iA {
                mount() {
                    let {
                        current: t
                    } = this.node;
                    t && (this.unmount = function(t, e, i = {}) {
                        let [n, r, s] = E(t, i), o = t => {
                            if (!A(t)) return;
                            let {
                                target: i
                            } = t, n = e(i, t);
                            if ("function" != typeof n || !i) return;
                            let s = t => {
                                A(t) && (n(t), i.removeEventListener("pointerleave", s))
                            };
                            i.addEventListener("pointerleave", s, r)
                        };
                        return n.forEach(t => {
                            t.addEventListener("pointerenter", o, r)
                        }), s
                    }(t, (t, e) => (rw(this.node, e, "Start"), t => rw(this.node, t, "End"))))
                }
                unmount() {}
            }
            class rP extends iA {
                constructor() {
                    super(...arguments), this.isActive = !1
                }
                onFocus() {
                    let t = !1;
                    try {
                        t = this.node.current.matches(":focus-visible")
                    } catch (e) {
                        t = !0
                    }
                    t && this.node.animationState && (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0)
                }
                onBlur() {
                    this.isActive && this.node.animationState && (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1)
                }
                mount() {
                    this.unmount = eN(iR(this.node.current, "focus", () => this.onFocus()), iR(this.node.current, "blur", () => this.onBlur()))
                }
                unmount() {}
            }

            function rb(t, e, i) {
                let {
                    props: n
                } = t;
                if (t.current instanceof HTMLButtonElement && t.current.disabled) return;
                t.animationState && n.whileTap && t.animationState.setActive("whileTap", "Start" === i);
                let r = n["onTap" + ("End" === i ? "" : i)];
                r && X.postRender(() => r(e, iV(e)))
            }
            class rE extends iA {
                mount() {
                    let {
                        current: t
                    } = this.node;
                    t && (this.unmount = function(t, e, i = {}) {
                        let [n, r, s] = E(t, i), o = t => {
                            let i = t.currentTarget;
                            if (!i || !B(t) || V.has(i)) return;
                            V.add(i), S(t, "set");
                            let n = e(i, t),
                                s = (t, e) => {
                                    i.removeEventListener("pointerup", o), i.removeEventListener("pointercancel", a), S(t, "release"), B(t) && V.has(i) && (V.delete(i), "function" == typeof n && n(t, {
                                        success: e
                                    }))
                                },
                                o = t => {
                                    var e, n;
                                    t.isTrusted && (e = t, n = i instanceof Element ? i.getBoundingClientRect() : {
                                        left: 0,
                                        top: 0,
                                        right: window.innerWidth,
                                        bottom: window.innerHeight
                                    }, e.clientX < n.left || e.clientX > n.right || e.clientY < n.top || e.clientY > n.bottom) ? s(t, !1) : s(t, !(i instanceof Element) || C(i, t.target))
                                },
                                a = t => {
                                    s(t, !1)
                                };
                            i.addEventListener("pointerup", o, r), i.addEventListener("pointercancel", a, r), i.addEventListener("lostpointercapture", a, r)
                        };
                        return n.forEach(t => {
                            t = i.useGlobalTarget ? window : t;
                            let e = !1;
                            if (t instanceof HTMLElement) {
                                var n;
                                e = !0, n = t, !R.has(n.tagName) && -1 === n.tabIndex && null === t.getAttribute("tabindex") && (t.tabIndex = 0)
                            }
                            t.addEventListener("pointerdown", o, r), e && t.addEventListener("focus", t => L(t, r), r)
                        }), s
                    }(t, (t, e) => (rb(this.node, e, "Start"), (t, {
                        success: e
                    }) => rb(this.node, t, e ? "End" : "Cancel")), {
                        useGlobalTarget: this.node.props.globalTapTarget
                    }))
                }
                unmount() {}
            }
            let rA = new WeakMap,
                rS = new WeakMap,
                rC = t => {
                    let e = rA.get(t.target);
                    e && e(t)
                },
                rM = t => {
                    t.forEach(rC)
                },
                rR = {
                    some: 0,
                    all: 1
                };
            class rV extends iA {
                constructor() {
                    super(...arguments), this.hasEnteredView = !1, this.isInView = !1
                }
                startObserver() {
                    this.unmount();
                    let {
                        viewport: t = {}
                    } = this.node.getProps(), {
                        root: e,
                        margin: i,
                        amount: n = "some",
                        once: r
                    } = t, s = {
                        root: e ? e.current : void 0,
                        rootMargin: i,
                        threshold: "number" == typeof n ? n : rR[n]
                    };
                    return function(t, e, i) {
                        let n = function({
                            root: t,
                            ...e
                        }) {
                            let i = t || document;
                            rS.has(i) || rS.set(i, {});
                            let n = rS.get(i),
                                r = JSON.stringify(e);
                            return n[r] || (n[r] = new IntersectionObserver(rM, {
                                root: t,
                                ...e
                            })), n[r]
                        }(e);
                        return rA.set(t, i), n.observe(t), () => {
                            rA.delete(t), n.unobserve(t)
                        }
                    }(this.node.current, s, t => {
                        let {
                            isIntersecting: e
                        } = t;
                        if (this.isInView === e || (this.isInView = e, r && !e && this.hasEnteredView)) return;
                        e && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", e);
                        let {
                            onViewportEnter: i,
                            onViewportLeave: n
                        } = this.node.getProps(), s = e ? i : n;
                        s && s(t)
                    })
                }
                mount() {
                    this.startObserver()
                }
                update() {
                    if ("undefined" == typeof IntersectionObserver) return;
                    let {
                        props: t,
                        prevProps: e
                    } = this.node;
                    ["amount", "margin", "root"].some(function({
                        viewport: t = {}
                    }, {
                        viewport: e = {}
                    } = {}) {
                        return i => t[i] !== e[i]
                    }(t, e)) && this.startObserver()
                }
                unmount() {}
            }
            let rk = (0, np.createContext)({
                strict: !1
            });
            var rD = i(27249);
            let rL = (0, np.createContext)({});

            function rB(t) {
                return r(t.animate) || ix.some(e => iv(t[e]))
            }

            function rj(t) {
                return !!(rB(t) || t.variants)
            }

            function rI(t) {
                return Array.isArray(t) ? t.join(" ") : t
            }
            var rF = i(15687);
            let rN = {
                    animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"],
                    exit: ["exit"],
                    drag: ["drag", "dragControls"],
                    focus: ["whileFocus"],
                    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
                    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
                    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
                    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
                    layout: ["layout", "layoutId"]
                },
                rO = {};
            for (let t in rN) rO[t] = {
                isEnabled: e => rN[t].some(t => !!e[t])
            };
            let rU = Symbol.for("motionComponentSymbol");
            var r$ = i(39656),
                rH = i(35403);

            function rz(t, {
                layout: e,
                layoutId: i
            }) {
                return O.has(t) || t.startsWith("origin") || (e || void 0 !== i) && (!!nP[t] || "opacity" === t)
            }
            let rY = (t, e) => e && "number" == typeof t ? e.transform(t) : t,
                rW = {
                    x: "translateX",
                    y: "translateY",
                    z: "translateZ",
                    transformPerspective: "perspective"
                },
                rK = N.length;

            function r_(t, e, i) {
                let {
                    style: n,
                    vars: r,
                    transformOrigin: s
                } = t, o = !1, a = !1;
                for (let t in e) {
                    let i = e[t];
                    if (O.has(t)) {
                        o = !0;
                        continue
                    }
                    if (em(t)) {
                        r[t] = i;
                        continue
                    } {
                        let e = rY(i, t8[t]);
                        t.startsWith("origin") ? (a = !0, s[t] = e) : n[t] = e
                    }
                }
                if (!e.transform && (o || i ? n.transform = function(t, e, i) {
                        let n = "",
                            r = !0;
                        for (let s = 0; s < rK; s++) {
                            let o = N[s],
                                a = t[o];
                            if (void 0 === a) continue;
                            let l = !0;
                            if (!(l = "number" == typeof a ? a === +!!o.startsWith("scale") : 0 === parseFloat(a)) || i) {
                                let t = rY(a, t8[o]);
                                if (!l) {
                                    r = !1;
                                    let e = rW[o] || o;
                                    n += `${e}(${t}) `
                                }
                                i && (e[o] = t)
                            }
                        }
                        return n = n.trim(), i ? n = i(e, r ? "" : n) : r && (n = "none"), n
                    }(e, t.transform, i) : n.transform && (n.transform = "none")), a) {
                    let {
                        originX: t = "50%",
                        originY: e = "50%",
                        originZ: i = 0
                    } = s;
                    n.transformOrigin = `${t} ${e} ${i}`
                }
            }
            let rX = () => ({
                style: {},
                transform: {},
                transformOrigin: {},
                vars: {}
            });

            function rq(t, e, i) {
                for (let n in e) ta(e[n]) || rz(n, i) || (t[n] = e[n])
            }
            let rJ = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]);

            function rQ(t) {
                return t.startsWith("while") || t.startsWith("drag") && "draggable" !== t || t.startsWith("layout") || t.startsWith("onTap") || t.startsWith("onPan") || t.startsWith("onLayout") || rJ.has(t)
            }
            let rG = t => !rQ(t);
            try {
                ! function(t) {
                    t && (rG = e => e.startsWith("on") ? !rQ(e) : t(e))
                }(require("@emotion/is-prop-valid").default)
            } catch (t) {}
            let rZ = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"];

            function r0(t) {
                if ("string" != typeof t || t.includes("-"));
                else if (rZ.indexOf(t) > -1 || /[A-Z]/u.test(t)) return !0;
                return !1
            }
            let r1 = {
                    offset: "stroke-dashoffset",
                    array: "stroke-dasharray"
                },
                r2 = {
                    offset: "strokeDashoffset",
                    array: "strokeDasharray"
                };

            function r5(t, e, i) {
                return "string" == typeof t ? t : tU.transform(e + i * t)
            }

            function r3(t, {
                attrX: e,
                attrY: i,
                attrScale: n,
                originX: r,
                originY: s,
                pathLength: o,
                pathSpacing: a = 1,
                pathOffset: l = 0,
                ...u
            }, h, d) {
                if (r_(t, u, d), h) {
                    t.style.viewBox && (t.attrs.viewBox = t.style.viewBox);
                    return
                }
                t.attrs = t.style, t.style = {};
                let {
                    attrs: c,
                    style: p,
                    dimensions: f
                } = t;
                c.transform && (f && (p.transform = c.transform), delete c.transform), f && (void 0 !== r || void 0 !== s || p.transform) && (p.transformOrigin = function(t, e, i) {
                    let n = r5(e, t.x, t.width),
                        r = r5(i, t.y, t.height);
                    return `${n} ${r}`
                }(f, void 0 !== r ? r : .5, void 0 !== s ? s : .5)), void 0 !== e && (c.x = e), void 0 !== i && (c.y = i), void 0 !== n && (c.scale = n), void 0 !== o && function(t, e, i = 1, n = 0, r = !0) {
                    t.pathLength = 1;
                    let s = r ? r1 : r2;
                    t[s.offset] = tU.transform(-n);
                    let o = tU.transform(e),
                        a = tU.transform(i);
                    t[s.array] = `${o} ${a}`
                }(c, o, a, l, !1)
            }
            let r4 = () => ({
                    ...rX(),
                    attrs: {}
                }),
                r8 = t => "string" == typeof t && "svg" === t.toLowerCase();
            var r6 = i(99234);
            let r7 = t => (e, i) => {
                let n = (0, np.useContext)(rL),
                    s = (0, np.useContext)(r$.t),
                    a = () => (function({
                        scrapeMotionValuesFromProps: t,
                        createRenderState: e,
                        onUpdate: i
                    }, n, s, a) {
                        let l = {
                            latestValues: function(t, e, i, n) {
                                let s = {},
                                    a = n(t, {});
                                for (let t in a) s[t] = nM(a[t]);
                                let {
                                    initial: l,
                                    animate: u
                                } = t, h = rB(t), d = rj(t);
                                e && d && !h && !1 !== t.inherit && (void 0 === l && (l = e.initial), void 0 === u && (u = e.animate));
                                let c = !!i && !1 === i.initial,
                                    p = (c = c || !1 === l) ? u : l;
                                if (p && "boolean" != typeof p && !r(p)) {
                                    let e = Array.isArray(p) ? p : [p];
                                    for (let i = 0; i < e.length; i++) {
                                        let n = o(t, e[i]);
                                        if (n) {
                                            let {
                                                transitionEnd: t,
                                                transition: e,
                                                ...i
                                            } = n;
                                            for (let t in i) {
                                                let e = i[t];
                                                if (Array.isArray(e)) {
                                                    let t = c ? e.length - 1 : 0;
                                                    e = e[t]
                                                }
                                                null !== e && (s[t] = e)
                                            }
                                            for (let e in t) s[e] = t[e]
                                        }
                                    }
                                }
                                return s
                            }(n, s, a, t),
                            renderState: e()
                        };
                        return i && (l.onMount = t => i({
                            props: n,
                            current: t,
                            ...l
                        }), l.onUpdate = t => i(t)), l
                    })(t, e, n, s);
                return i ? a() : (0, r6.M)(a)
            };

            function r9(t, e, i) {
                var n;
                let {
                    style: r
                } = t, s = {};
                for (let o in r)(ta(r[o]) || e.style && ta(e.style[o]) || rz(o, t) || (null === (n = null == i ? void 0 : i.getValue(o)) || void 0 === n ? void 0 : n.liveStyle) !== void 0) && (s[o] = r[o]);
                return s
            }
            let st = {
                useVisualState: r7({
                    scrapeMotionValuesFromProps: r9,
                    createRenderState: rX
                })
            };

            function se(t, e) {
                try {
                    e.dimensions = "function" == typeof t.getBBox ? t.getBBox() : t.getBoundingClientRect()
                } catch (t) {
                    e.dimensions = {
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0
                    }
                }
            }

            function si(t, {
                style: e,
                vars: i
            }, n, r) {
                for (let s in Object.assign(t.style, e, r && r.getProjectionStyles(n)), i) t.style.setProperty(s, i[s])
            }
            let sn = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);

            function sr(t, e, i, n) {
                for (let i in si(t, e, void 0, n), e.attrs) t.setAttribute(sn.has(i) ? i : tu(i), e.attrs[i])
            }

            function ss(t, e, i) {
                let n = r9(t, e, i);
                for (let i in t)(ta(t[i]) || ta(e[i])) && (n[-1 !== N.indexOf(i) ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i] = t[i]);
                return n
            }
            let so = ["x", "y", "width", "height", "cx", "cy", "r"],
                sa = {
                    useVisualState: r7({
                        scrapeMotionValuesFromProps: ss,
                        createRenderState: r4,
                        onUpdate: ({
                            props: t,
                            prevProps: e,
                            current: i,
                            renderState: n,
                            latestValues: r
                        }) => {
                            if (!i) return;
                            let s = !!t.drag;
                            if (!s) {
                                for (let t in r)
                                    if (O.has(t)) {
                                        s = !0;
                                        break
                                    }
                            }
                            if (!s) return;
                            let o = !e;
                            if (e)
                                for (let i = 0; i < so.length; i++) {
                                    let n = so[i];
                                    t[n] !== e[n] && (o = !0)
                                }
                            o && X.read(() => {
                                se(i, n), X.render(() => {
                                    r3(n, r, r8(i.tagName), t.transformTemplate), sr(i, n)
                                })
                            })
                        }
                    })
                },
                sl = {
                    current: null
                },
                su = {
                    current: !1
                },
                sh = [...eT, tW, t0],
                sd = t => sh.find(ew(t)),
                sc = new WeakMap,
                sp = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"];
            class sf {
                scrapeMotionValuesFromProps(t, e, i) {
                    return {}
                }
                constructor({
                    parent: t,
                    props: e,
                    presenceContext: i,
                    reducedMotionConfig: n,
                    blockInitialAnimation: r,
                    visualState: s
                }, o = {}) {
                    this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.KeyframeResolver = ec, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
                        this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
                    }, this.renderScheduledAt = 0, this.scheduleRender = () => {
                        let t = Z.now();
                        this.renderScheduledAt < t && (this.renderScheduledAt = t, X.render(this.render, !1, !0))
                    };
                    let {
                        latestValues: a,
                        renderState: l,
                        onUpdate: u
                    } = s;
                    this.onUpdate = u, this.latestValues = a, this.baseTarget = {
                        ...a
                    }, this.initialValues = e.initial ? {
                        ...a
                    } : {}, this.renderState = l, this.parent = t, this.props = e, this.presenceContext = i, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = n, this.options = o, this.blockInitialAnimation = !!r, this.isControllingVariants = rB(e), this.isVariantNode = rj(e), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(t && t.current);
                    let {
                        willChange: h,
                        ...d
                    } = this.scrapeMotionValuesFromProps(e, {}, this);
                    for (let t in d) {
                        let e = d[t];
                        void 0 !== a[t] && ta(e) && e.set(a[t], !1)
                    }
                }
                mount(t) {
                    this.current = t, sc.set(t, this), this.projection && !this.projection.instance && this.projection.mount(t), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((t, e) => this.bindToMotionValue(e, t)), su.current || function() {
                        if (su.current = !0, rF.B) {
                            if (window.matchMedia) {
                                let t = window.matchMedia("(prefers-reduced-motion)"),
                                    e = () => sl.current = t.matches;
                                t.addListener(e), e()
                            } else sl.current = !1
                        }
                    }(), this.shouldReduceMotion = "never" !== this.reducedMotionConfig && ("always" === this.reducedMotionConfig || sl.current), this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext)
                }
                unmount() {
                    for (let t in this.projection && this.projection.unmount(), q(this.notifyUpdate), q(this.render), this.valueSubscriptions.forEach(t => t()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this), this.events) this.events[t].clear();
                    for (let t in this.features) {
                        let e = this.features[t];
                        e && (e.unmount(), e.isMounted = !1)
                    }
                    this.current = null
                }
                bindToMotionValue(t, e) {
                    let i;
                    this.valueSubscriptions.has(t) && this.valueSubscriptions.get(t)();
                    let n = O.has(t);
                    n && this.onBindTransform && this.onBindTransform();
                    let r = e.on("change", e => {
                            this.latestValues[t] = e, this.props.onUpdate && X.preRender(this.notifyUpdate), n && this.projection && (this.projection.isTransformDirty = !0)
                        }),
                        s = e.on("renderRequest", this.scheduleRender);
                    window.MotionCheckAppearSync && (i = window.MotionCheckAppearSync(this, t, e)), this.valueSubscriptions.set(t, () => {
                        r(), s(), i && i(), e.owner && e.stop()
                    })
                }
                sortNodePosition(t) {
                    return this.current && this.sortInstanceNodePosition && this.type === t.type ? this.sortInstanceNodePosition(this.current, t.current) : 0
                }
                updateFeatures() {
                    let t = "animation";
                    for (t in rO) {
                        let e = rO[t];
                        if (!e) continue;
                        let {
                            isEnabled: i,
                            Feature: n
                        } = e;
                        if (!this.features[t] && n && i(this.props) && (this.features[t] = new n(this)), this.features[t]) {
                            let e = this.features[t];
                            e.isMounted ? e.update() : (e.mount(), e.isMounted = !0)
                        }
                    }
                }
                triggerBuild() {
                    this.build(this.renderState, this.latestValues, this.props)
                }
                measureViewportBox() {
                    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : iz()
                }
                getStaticValue(t) {
                    return this.latestValues[t]
                }
                setStaticValue(t, e) {
                    this.latestValues[t] = e
                }
                update(t, e) {
                    (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = t, this.prevPresenceContext = this.presenceContext, this.presenceContext = e;
                    for (let e = 0; e < sp.length; e++) {
                        let i = sp[e];
                        this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i]);
                        let n = t["on" + i];
                        n && (this.propEventSubscriptions[i] = this.on(i, n))
                    }
                    this.prevMotionValues = function(t, e, i) {
                        for (let n in e) {
                            let r = e[n],
                                s = i[n];
                            if (ta(r)) t.addValue(n, r);
                            else if (ta(s)) t.addValue(n, to(r, {
                                owner: t
                            }));
                            else if (s !== r) {
                                if (t.hasValue(n)) {
                                    let e = t.getValue(n);
                                    !0 === e.liveStyle ? e.jump(r) : e.hasAnimated || e.set(r)
                                } else {
                                    let e = t.getStaticValue(n);
                                    t.addValue(n, to(void 0 !== e ? e : r, {
                                        owner: t
                                    }))
                                }
                            }
                        }
                        for (let n in i) void 0 === e[n] && t.removeValue(n);
                        return e
                    }(this, this.scrapeMotionValuesFromProps(t, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue(), this.onUpdate && this.onUpdate(this)
                }
                getProps() {
                    return this.props
                }
                getVariant(t) {
                    return this.props.variants ? this.props.variants[t] : void 0
                }
                getDefaultTransition() {
                    return this.props.transition
                }
                getTransformPagePoint() {
                    return this.props.transformPagePoint
                }
                getClosestVariantNode() {
                    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
                }
                addVariantChild(t) {
                    let e = this.getClosestVariantNode();
                    if (e) return e.variantChildren && e.variantChildren.add(t), () => e.variantChildren.delete(t)
                }
                addValue(t, e) {
                    let i = this.values.get(t);
                    e !== i && (i && this.removeValue(t), this.bindToMotionValue(t, e), this.values.set(t, e), this.latestValues[t] = e.get())
                }
                removeValue(t) {
                    this.values.delete(t);
                    let e = this.valueSubscriptions.get(t);
                    e && (e(), this.valueSubscriptions.delete(t)), delete this.latestValues[t], this.removeValueFromRenderState(t, this.renderState)
                }
                hasValue(t) {
                    return this.values.has(t)
                }
                getValue(t, e) {
                    if (this.props.values && this.props.values[t]) return this.props.values[t];
                    let i = this.values.get(t);
                    return void 0 === i && void 0 !== e && (i = to(null === e ? void 0 : e, {
                        owner: this
                    }), this.addValue(t, i)), i
                }
                readValue(t, e) {
                    var i;
                    let n = void 0 === this.latestValues[t] && this.current ? null !== (i = this.getBaseTargetFromProps(this.props, t)) && void 0 !== i ? i : this.readValueFromInstance(this.current, t, this.options) : this.latestValues[t];
                    return null != n && ("string" == typeof n && (ep(n) || tb(n)) ? n = parseFloat(n) : !sd(n) && t0.test(e) && (n = t9(t, e)), this.setBaseTarget(t, ta(n) ? n.get() : n)), ta(n) ? n.get() : n
                }
                setBaseTarget(t, e) {
                    this.baseTarget[t] = e
                }
                getBaseTarget(t) {
                    var e;
                    let i;
                    let {
                        initial: n
                    } = this.props;
                    if ("string" == typeof n || "object" == typeof n) {
                        let r = o(this.props, n, null === (e = this.presenceContext) || void 0 === e ? void 0 : e.custom);
                        r && (i = r[t])
                    }
                    if (n && void 0 !== i) return i;
                    let r = this.getBaseTargetFromProps(this.props, t);
                    return void 0 === r || ta(r) ? void 0 !== this.initialValues[t] && void 0 === i ? void 0 : this.baseTarget[t] : r
                }
                on(t, e) {
                    return this.events[t] || (this.events[t] = new ti), this.events[t].add(e)
                }
                notify(t, ...e) {
                    this.events[t] && this.events[t].notify(...e)
                }
            }
            class sm extends sf {
                constructor() {
                    super(...arguments), this.KeyframeResolver = eb
                }
                sortInstanceNodePosition(t, e) {
                    return 2 & t.compareDocumentPosition(e) ? 1 : -1
                }
                getBaseTargetFromProps(t, e) {
                    return t.style ? t.style[e] : void 0
                }
                removeValueFromRenderState(t, {
                    vars: e,
                    style: i
                }) {
                    delete e[t], delete i[t]
                }
                handleChildMotionValue() {
                    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
                    let {
                        children: t
                    } = this.props;
                    ta(t) && (this.childSubscription = t.on("change", t => {
                        this.current && (this.current.textContent = `${t}`)
                    }))
                }
            }
            class sg extends sm {
                constructor() {
                    super(...arguments), this.type = "html", this.renderInstance = si
                }
                readValueFromInstance(t, e) {
                    if (O.has(e)) {
                        let t = t7(e);
                        return t && t.default || 0
                    } {
                        let i = window.getComputedStyle(t),
                            n = (em(e) ? i.getPropertyValue(e) : i[e]) || 0;
                        return "string" == typeof n ? n.trim() : n
                    }
                }
                measureInstanceViewportBox(t, {
                    transformPagePoint: e
                }) {
                    return i1(t, e)
                }
                build(t, e, i) {
                    r_(t, e, i.transformTemplate)
                }
                scrapeMotionValuesFromProps(t, e, i) {
                    return r9(t, e, i)
                }
            }
            class sv extends sm {
                constructor() {
                    super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = iz, this.updateDimensions = () => {
                        this.current && !this.renderState.dimensions && se(this.current, this.renderState)
                    }
                }
                getBaseTargetFromProps(t, e) {
                    return t[e]
                }
                readValueFromInstance(t, e) {
                    if (O.has(e)) {
                        let t = t7(e);
                        return t && t.default || 0
                    }
                    return e = sn.has(e) ? e : tu(e), t.getAttribute(e)
                }
                scrapeMotionValuesFromProps(t, e, i) {
                    return ss(t, e, i)
                }
                onBindTransform() {
                    this.current && !this.renderState.dimensions && X.postRender(this.updateDimensions)
                }
                build(t, e, i) {
                    r3(t, e, this.isSVGTag, i.transformTemplate)
                }
                renderInstance(t, e, i, n) {
                    sr(t, e, i, n)
                }
                mount(t) {
                    this.isSVGTag = r8(t.tagName), super.mount(t)
                }
            }
            let sy = function(t) {
                if ("undefined" == typeof Proxy) return t;
                let e = new Map;
                return new Proxy((...e) => t(...e), {
                    get: (i, n) => "create" === n ? t : (e.has(n) || e.set(n, t(n)), e.get(n))
                })
            }((nh = {
                animation: {
                    Feature: iS
                },
                exit: {
                    Feature: iM
                },
                inView: {
                    Feature: rV
                },
                tap: {
                    Feature: rE
                },
                focus: {
                    Feature: rP
                },
                hover: {
                    Feature: rT
                },
                pan: {
                    Feature: nu
                },
                drag: {
                    Feature: na,
                    ProjectionNode: rx,
                    MeasureLayout: nE
                },
                layout: {
                    ProjectionNode: rx,
                    MeasureLayout: nE
                }
            }, nd = (t, e) => r0(t) ? new sv(e) : new sg(e, {
                allowProjection: t !== np.Fragment
            }), function(t, {
                forwardMotionProps: e
            } = {
                forwardMotionProps: !1
            }) {
                return function(t) {
                    var e, i;
                    let {
                        preloadedFeatures: n,
                        createVisualElement: r,
                        useRender: s,
                        useVisualState: o,
                        Component: a
                    } = t;

                    function l(t, e) {
                        var i, n, l;
                        let u;
                        let h = {
                                ...(0, np.useContext)(rD.Q),
                                ...t,
                                layoutId: function(t) {
                                    let {
                                        layoutId: e
                                    } = t, i = (0, np.useContext)(nm.L).id;
                                    return i && void 0 !== e ? i + "-" + e : e
                                }(t)
                            },
                            {
                                isStatic: d
                            } = h,
                            c = function(t) {
                                let {
                                    initial: e,
                                    animate: i
                                } = function(t, e) {
                                    if (rB(t)) {
                                        let {
                                            initial: e,
                                            animate: i
                                        } = t;
                                        return {
                                            initial: !1 === e || iv(e) ? e : void 0,
                                            animate: iv(i) ? i : void 0
                                        }
                                    }
                                    return !1 !== t.inherit ? e : {}
                                }(t, (0, np.useContext)(rL));
                                return (0, np.useMemo)(() => ({
                                    initial: e,
                                    animate: i
                                }), [rI(e), rI(i)])
                            }(t),
                            p = o(t, d);
                        if (!d && rF.B) {
                            n = 0, l = 0, (0, np.useContext)(rk).strict;
                            let t = function(t) {
                                let {
                                    drag: e,
                                    layout: i
                                } = rO;
                                if (!e && !i) return {};
                                let n = {
                                    ...e,
                                    ...i
                                };
                                return {
                                    MeasureLayout: (null == e ? void 0 : e.isEnabled(t)) || (null == i ? void 0 : i.isEnabled(t)) ? n.MeasureLayout : void 0,
                                    ProjectionNode: n.ProjectionNode
                                }
                            }(h);
                            u = t.MeasureLayout, c.visualElement = function(t, e, i, n, r) {
                                var s, o;
                                let {
                                    visualElement: a
                                } = (0, np.useContext)(rL), l = (0, np.useContext)(rk), u = (0, np.useContext)(r$.t), h = (0, np.useContext)(rD.Q).reducedMotion, d = (0, np.useRef)(null);
                                n = n || l.renderer, !d.current && n && (d.current = n(t, {
                                    visualState: e,
                                    parent: a,
                                    props: i,
                                    presenceContext: u,
                                    blockInitialAnimation: !!u && !1 === u.initial,
                                    reducedMotionConfig: h
                                }));
                                let c = d.current,
                                    p = (0, np.useContext)(ng);
                                c && !c.projection && r && ("html" === c.type || "svg" === c.type) && function(t, e, i, n) {
                                    let {
                                        layoutId: r,
                                        layout: s,
                                        drag: o,
                                        dragConstraints: a,
                                        layoutScroll: l,
                                        layoutRoot: u
                                    } = e;
                                    t.projection = new i(t.latestValues, e["data-framer-portal-id"] ? void 0 : function t(e) {
                                        if (e) return !1 !== e.options.allowProjection ? e.projection : t(e.parent)
                                    }(t.parent)), t.projection.setOptions({
                                        layoutId: r,
                                        layout: s,
                                        alwaysMeasureLayout: !!o || a && i2(a),
                                        visualElement: t,
                                        animationType: "string" == typeof s ? s : "both",
                                        initialPromotionConfig: n,
                                        layoutScroll: l,
                                        layoutRoot: u
                                    })
                                }(d.current, i, r, p);
                                let f = (0, np.useRef)(!1);
                                (0, np.useInsertionEffect)(() => {
                                    c && f.current && c.update(i, u)
                                });
                                let m = i[th],
                                    g = (0, np.useRef)(!!m && !(null === (s = window.MotionHandoffIsComplete) || void 0 === s ? void 0 : s.call(window, m)) && (null === (o = window.MotionHasOptimisedAnimation) || void 0 === o ? void 0 : o.call(window, m)));
                                return (0, rH.E)(() => {
                                    c && (f.current = !0, window.MotionIsMounted = !0, c.updateFeatures(), nv.render(c.render), g.current && c.animationState && c.animationState.animateChanges())
                                }), (0, np.useEffect)(() => {
                                    c && (!g.current && c.animationState && c.animationState.animateChanges(), g.current && (queueMicrotask(() => {
                                        var t;
                                        null === (t = window.MotionHandoffMarkAsComplete) || void 0 === t || t.call(window, m)
                                    }), g.current = !1))
                                }), c
                            }(a, p, h, r, t.ProjectionNode)
                        }
                        return (0, nc.jsxs)(rL.Provider, {
                            value: c,
                            children: [u && c.visualElement ? (0, nc.jsx)(u, {
                                visualElement: c.visualElement,
                                ...h
                            }) : null, s(a, t, (i = c.visualElement, (0, np.useCallback)(t => {
                                t && p.onMount && p.onMount(t), i && (t ? i.mount(t) : i.unmount()), e && ("function" == typeof e ? e(t) : i2(e) && (e.current = t))
                            }, [i])), p, d, c.visualElement)]
                        })
                    }
                    n && function(t) {
                        for (let e in t) rO[e] = {
                            ...rO[e],
                            ...t[e]
                        }
                    }(n), l.displayName = "motion.".concat("string" == typeof a ? a : "create(".concat(null !== (i = null !== (e = a.displayName) && void 0 !== e ? e : a.name) && void 0 !== i ? i : "", ")"));
                    let u = (0, np.forwardRef)(l);
                    return u[rU] = a, u
                }({
                    ...r0(t) ? sa : st,
                    preloadedFeatures: nh,
                    useRender: function(t = !1) {
                        return (e, i, n, {
                            latestValues: r
                        }, s) => {
                            let o = (r0(e) ? function(t, e, i, n) {
                                    let r = (0, np.useMemo)(() => {
                                        let i = r4();
                                        return r3(i, e, r8(n), t.transformTemplate), {
                                            ...i.attrs,
                                            style: {
                                                ...i.style
                                            }
                                        }
                                    }, [e]);
                                    if (t.style) {
                                        let e = {};
                                        rq(e, t.style, t), r.style = {
                                            ...e,
                                            ...r.style
                                        }
                                    }
                                    return r
                                } : function(t, e) {
                                    let i = {},
                                        n = function(t, e) {
                                            let i = t.style || {},
                                                n = {};
                                            return rq(n, i, t), Object.assign(n, function({
                                                transformTemplate: t
                                            }, e) {
                                                return (0, np.useMemo)(() => {
                                                    let i = rX();
                                                    return r_(i, e, t), Object.assign({}, i.vars, i.style)
                                                }, [e])
                                            }(t, e)), n
                                        }(t, e);
                                    return t.drag && !1 !== t.dragListener && (i.draggable = !1, n.userSelect = n.WebkitUserSelect = n.WebkitTouchCallout = "none", n.touchAction = !0 === t.drag ? "none" : `pan-${"x"===t.drag?"y":"x"}`), void 0 === t.tabIndex && (t.onTap || t.onTapStart || t.whileTap) && (i.tabIndex = 0), i.style = n, i
                                })(i, r, s, e),
                                a = function(t, e, i) {
                                    let n = {};
                                    for (let r in t)("values" !== r || "object" != typeof t.values) && (rG(r) || !0 === i && rQ(r) || !e && !rQ(r) || t.draggable && r.startsWith("onDrag")) && (n[r] = t[r]);
                                    return n
                                }(i, "string" == typeof e, t),
                                l = e !== np.Fragment ? {
                                    ...a,
                                    ...o,
                                    ref: n
                                } : {},
                                {
                                    children: u
                                } = i,
                                h = (0, np.useMemo)(() => ta(u) ? u.get() : u, [u]);
                            return (0, np.createElement)(e, {
                                ...l,
                                children: h
                            })
                        }
                    }(e),
                    createVisualElement: nd,
                    Component: t
                })
            }))
        },
        15687: (t, e, i) => {
            "use strict";
            i.d(e, {
                B: () => n
            });
            let n = "undefined" != typeof window
        },
        16383: (t, e, i) => {
            let n = i(62172);
            e.render = function(t, e, i) {
                var r;
                let s = i,
                    o = e;
                void 0 !== s || e && e.getContext || (s = e, e = void 0), e || (o = function() {
                    try {
                        return document.createElement("canvas")
                    } catch (t) {
                        throw Error("You need to specify a canvas element")
                    }
                }()), s = n.getOptions(s);
                let a = n.getImageWidth(t.modules.size, s),
                    l = o.getContext("2d"),
                    u = l.createImageData(a, a);
                return n.qrToImageData(u.data, t, s), r = o, l.clearRect(0, 0, r.width, r.height), r.style || (r.style = {}), r.height = a, r.width = a, r.style.height = a + "px", r.style.width = a + "px", l.putImageData(u, 0, 0), o
            }, e.renderToDataURL = function(t, i, n) {
                let r = n;
                void 0 !== r || i && i.getContext || (r = i, i = void 0), r || (r = {});
                let s = e.render(t, i, r),
                    o = r.type || "image/png",
                    a = r.rendererOpts || {};
                return s.toDataURL(o, a.quality)
            }
        },
        19710: (t, e, i) => {
            "use strict";
            i.d(e, {
                Kq: () => z,
                UC: () => _,
                ZL: () => K,
                bL: () => Y,
                i3: () => X,
                l9: () => W
            });
            var n = i(12115),
                r = i(93610),
                s = i(88068),
                o = i(18166),
                a = i(59674),
                l = i(67668),
                u = i(10418),
                h = i(17323),
                d = i(17028),
                c = i(23360),
                p = i(12317),
                f = i(1488),
                m = i(63543),
                g = i(95155),
                [v, y] = (0, o.A)("Tooltip", [u.Bk]),
                x = (0, u.Bk)(),
                w = "TooltipProvider",
                T = "tooltip.open",
                [P, b] = v(w),
                E = t => {
                    let {
                        __scopeTooltip: e,
                        delayDuration: i = 700,
                        skipDelayDuration: r = 300,
                        disableHoverableContent: s = !1,
                        children: o
                    } = t, [a, l] = n.useState(!0), u = n.useRef(!1), h = n.useRef(0);
                    return n.useEffect(() => {
                        let t = h.current;
                        return () => window.clearTimeout(t)
                    }, []), (0, g.jsx)(P, {
                        scope: e,
                        isOpenDelayed: a,
                        delayDuration: i,
                        onOpen: n.useCallback(() => {
                            window.clearTimeout(h.current), l(!1)
                        }, []),
                        onClose: n.useCallback(() => {
                            window.clearTimeout(h.current), h.current = window.setTimeout(() => l(!0), r)
                        }, [r]),
                        isPointerInTransitRef: u,
                        onPointerInTransitChange: n.useCallback(t => {
                            u.current = t
                        }, []),
                        disableHoverableContent: s,
                        children: o
                    })
                };
            E.displayName = w;
            var A = "Tooltip",
                [S, C] = v(A),
                M = t => {
                    let {
                        __scopeTooltip: e,
                        children: i,
                        open: r,
                        defaultOpen: s = !1,
                        onOpenChange: o,
                        disableHoverableContent: a,
                        delayDuration: h
                    } = t, d = b(A, t.__scopeTooltip), c = x(e), [p, m] = n.useState(null), v = (0, l.B)(), y = n.useRef(0), w = null != a ? a : d.disableHoverableContent, P = null != h ? h : d.delayDuration, E = n.useRef(!1), [C = !1, M] = (0, f.i)({
                        prop: r,
                        defaultProp: s,
                        onChange: t => {
                            t ? (d.onOpen(), document.dispatchEvent(new CustomEvent(T))) : d.onClose(), null == o || o(t)
                        }
                    }), R = n.useMemo(() => C ? E.current ? "delayed-open" : "instant-open" : "closed", [C]), V = n.useCallback(() => {
                        window.clearTimeout(y.current), y.current = 0, E.current = !1, M(!0)
                    }, [M]), k = n.useCallback(() => {
                        window.clearTimeout(y.current), y.current = 0, M(!1)
                    }, [M]), D = n.useCallback(() => {
                        window.clearTimeout(y.current), y.current = window.setTimeout(() => {
                            E.current = !0, M(!0), y.current = 0
                        }, P)
                    }, [P, M]);
                    return n.useEffect(() => () => {
                        y.current && (window.clearTimeout(y.current), y.current = 0)
                    }, []), (0, g.jsx)(u.bL, {
                        ...c,
                        children: (0, g.jsx)(S, {
                            scope: e,
                            contentId: v,
                            open: C,
                            stateAttribute: R,
                            trigger: p,
                            onTriggerChange: m,
                            onTriggerEnter: n.useCallback(() => {
                                d.isOpenDelayed ? D() : V()
                            }, [d.isOpenDelayed, D, V]),
                            onTriggerLeave: n.useCallback(() => {
                                w ? k() : (window.clearTimeout(y.current), y.current = 0)
                            }, [k, w]),
                            onOpen: V,
                            onClose: k,
                            disableHoverableContent: w,
                            children: i
                        })
                    })
                };
            M.displayName = A;
            var R = "TooltipTrigger",
                V = n.forwardRef((t, e) => {
                    let {
                        __scopeTooltip: i,
                        ...o
                    } = t, a = C(R, i), l = b(R, i), h = x(i), d = n.useRef(null), p = (0, s.s)(e, d, a.onTriggerChange), f = n.useRef(!1), m = n.useRef(!1), v = n.useCallback(() => f.current = !1, []);
                    return n.useEffect(() => () => document.removeEventListener("pointerup", v), [v]), (0, g.jsx)(u.Mz, {
                        asChild: !0,
                        ...h,
                        children: (0, g.jsx)(c.sG.button, {
                            "aria-describedby": a.open ? a.contentId : void 0,
                            "data-state": a.stateAttribute,
                            ...o,
                            ref: p,
                            onPointerMove: (0, r.m)(t.onPointerMove, t => {
                                "touch" === t.pointerType || m.current || l.isPointerInTransitRef.current || (a.onTriggerEnter(), m.current = !0)
                            }),
                            onPointerLeave: (0, r.m)(t.onPointerLeave, () => {
                                a.onTriggerLeave(), m.current = !1
                            }),
                            onPointerDown: (0, r.m)(t.onPointerDown, () => {
                                f.current = !0, document.addEventListener("pointerup", v, {
                                    once: !0
                                })
                            }),
                            onFocus: (0, r.m)(t.onFocus, () => {
                                f.current || a.onOpen()
                            }),
                            onBlur: (0, r.m)(t.onBlur, a.onClose),
                            onClick: (0, r.m)(t.onClick, a.onClose)
                        })
                    })
                });
            V.displayName = R;
            var k = "TooltipPortal",
                [D, L] = v(k, {
                    forceMount: void 0
                }),
                B = t => {
                    let {
                        __scopeTooltip: e,
                        forceMount: i,
                        children: n,
                        container: r
                    } = t, s = C(k, e);
                    return (0, g.jsx)(D, {
                        scope: e,
                        forceMount: i,
                        children: (0, g.jsx)(d.C, {
                            present: i || s.open,
                            children: (0, g.jsx)(h.Z, {
                                asChild: !0,
                                container: r,
                                children: n
                            })
                        })
                    })
                };
            B.displayName = k;
            var j = "TooltipContent",
                I = n.forwardRef((t, e) => {
                    let i = L(j, t.__scopeTooltip),
                        {
                            forceMount: n = i.forceMount,
                            side: r = "top",
                            ...s
                        } = t,
                        o = C(j, t.__scopeTooltip);
                    return (0, g.jsx)(d.C, {
                        present: n || o.open,
                        children: o.disableHoverableContent ? (0, g.jsx)(U, {
                            side: r,
                            ...s,
                            ref: e
                        }) : (0, g.jsx)(F, {
                            side: r,
                            ...s,
                            ref: e
                        })
                    })
                }),
                F = n.forwardRef((t, e) => {
                    let i = C(j, t.__scopeTooltip),
                        r = b(j, t.__scopeTooltip),
                        o = n.useRef(null),
                        a = (0, s.s)(e, o),
                        [l, u] = n.useState(null),
                        {
                            trigger: h,
                            onClose: d
                        } = i,
                        c = o.current,
                        {
                            onPointerInTransitChange: p
                        } = r,
                        f = n.useCallback(() => {
                            u(null), p(!1)
                        }, [p]),
                        m = n.useCallback((t, e) => {
                            let i = t.currentTarget,
                                n = {
                                    x: t.clientX,
                                    y: t.clientY
                                },
                                r = function(t, e) {
                                    let i = Math.abs(e.top - t.y),
                                        n = Math.abs(e.bottom - t.y),
                                        r = Math.abs(e.right - t.x),
                                        s = Math.abs(e.left - t.x);
                                    switch (Math.min(i, n, r, s)) {
                                        case s:
                                            return "left";
                                        case r:
                                            return "right";
                                        case i:
                                            return "top";
                                        case n:
                                            return "bottom";
                                        default:
                                            throw Error("unreachable")
                                    }
                                }(n, i.getBoundingClientRect());
                            u(function(t) {
                                let e = t.slice();
                                return e.sort((t, e) => t.x < e.x ? -1 : t.x > e.x ? 1 : t.y < e.y ? -1 : +!!(t.y > e.y)),
                                    function(t) {
                                        if (t.length <= 1) return t.slice();
                                        let e = [];
                                        for (let i = 0; i < t.length; i++) {
                                            let n = t[i];
                                            for (; e.length >= 2;) {
                                                let t = e[e.length - 1],
                                                    i = e[e.length - 2];
                                                if ((t.x - i.x) * (n.y - i.y) >= (t.y - i.y) * (n.x - i.x)) e.pop();
                                                else break
                                            }
                                            e.push(n)
                                        }
                                        e.pop();
                                        let i = [];
                                        for (let e = t.length - 1; e >= 0; e--) {
                                            let n = t[e];
                                            for (; i.length >= 2;) {
                                                let t = i[i.length - 1],
                                                    e = i[i.length - 2];
                                                if ((t.x - e.x) * (n.y - e.y) >= (t.y - e.y) * (n.x - e.x)) i.pop();
                                                else break
                                            }
                                            i.push(n)
                                        }
                                        return (i.pop(), 1 === e.length && 1 === i.length && e[0].x === i[0].x && e[0].y === i[0].y) ? e : e.concat(i)
                                    }(e)
                            }([... function(t, e) {
                                let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 5,
                                    n = [];
                                switch (e) {
                                    case "top":
                                        n.push({
                                            x: t.x - i,
                                            y: t.y + i
                                        }, {
                                            x: t.x + i,
                                            y: t.y + i
                                        });
                                        break;
                                    case "bottom":
                                        n.push({
                                            x: t.x - i,
                                            y: t.y - i
                                        }, {
                                            x: t.x + i,
                                            y: t.y - i
                                        });
                                        break;
                                    case "left":
                                        n.push({
                                            x: t.x + i,
                                            y: t.y - i
                                        }, {
                                            x: t.x + i,
                                            y: t.y + i
                                        });
                                        break;
                                    case "right":
                                        n.push({
                                            x: t.x - i,
                                            y: t.y - i
                                        }, {
                                            x: t.x - i,
                                            y: t.y + i
                                        })
                                }
                                return n
                            }(n, r), ... function(t) {
                                let {
                                    top: e,
                                    right: i,
                                    bottom: n,
                                    left: r
                                } = t;
                                return [{
                                    x: r,
                                    y: e
                                }, {
                                    x: i,
                                    y: e
                                }, {
                                    x: i,
                                    y: n
                                }, {
                                    x: r,
                                    y: n
                                }]
                            }(e.getBoundingClientRect())])), p(!0)
                        }, [p]);
                    return n.useEffect(() => () => f(), [f]), n.useEffect(() => {
                        if (h && c) {
                            let t = t => m(t, c),
                                e = t => m(t, h);
                            return h.addEventListener("pointerleave", t), c.addEventListener("pointerleave", e), () => {
                                h.removeEventListener("pointerleave", t), c.removeEventListener("pointerleave", e)
                            }
                        }
                    }, [h, c, m, f]), n.useEffect(() => {
                        if (l) {
                            let t = t => {
                                let e = t.target,
                                    i = {
                                        x: t.clientX,
                                        y: t.clientY
                                    },
                                    n = (null == h ? void 0 : h.contains(e)) || (null == c ? void 0 : c.contains(e)),
                                    r = ! function(t, e) {
                                        let {
                                            x: i,
                                            y: n
                                        } = t, r = !1;
                                        for (let t = 0, s = e.length - 1; t < e.length; s = t++) {
                                            let o = e[t].x,
                                                a = e[t].y,
                                                l = e[s].x,
                                                u = e[s].y;
                                            a > n != u > n && i < (l - o) * (n - a) / (u - a) + o && (r = !r)
                                        }
                                        return r
                                    }(i, l);
                                n ? f() : r && (f(), d())
                            };
                            return document.addEventListener("pointermove", t), () => document.removeEventListener("pointermove", t)
                        }
                    }, [h, c, l, d, f]), (0, g.jsx)(U, {
                        ...t,
                        ref: a
                    })
                }),
                [N, O] = v(A, {
                    isInside: !1
                }),
                U = n.forwardRef((t, e) => {
                    let {
                        __scopeTooltip: i,
                        children: r,
                        "aria-label": s,
                        onEscapeKeyDown: o,
                        onPointerDownOutside: l,
                        ...h
                    } = t, d = C(j, i), c = x(i), {
                        onClose: f
                    } = d;
                    return n.useEffect(() => (document.addEventListener(T, f), () => document.removeEventListener(T, f)), [f]), n.useEffect(() => {
                        if (d.trigger) {
                            let t = t => {
                                let e = t.target;
                                (null == e ? void 0 : e.contains(d.trigger)) && f()
                            };
                            return window.addEventListener("scroll", t, {
                                capture: !0
                            }), () => window.removeEventListener("scroll", t, {
                                capture: !0
                            })
                        }
                    }, [d.trigger, f]), (0, g.jsx)(a.qW, {
                        asChild: !0,
                        disableOutsidePointerEvents: !1,
                        onEscapeKeyDown: o,
                        onPointerDownOutside: l,
                        onFocusOutside: t => t.preventDefault(),
                        onDismiss: f,
                        children: (0, g.jsxs)(u.UC, {
                            "data-state": d.stateAttribute,
                            ...c,
                            ...h,
                            ref: e,
                            style: {
                                ...h.style,
                                "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
                                "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
                                "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
                                "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
                                "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
                            },
                            children: [(0, g.jsx)(p.xV, {
                                children: r
                            }), (0, g.jsx)(N, {
                                scope: i,
                                isInside: !0,
                                children: (0, g.jsx)(m.b, {
                                    id: d.contentId,
                                    role: "tooltip",
                                    children: s || r
                                })
                            })]
                        })
                    })
                });
            I.displayName = j;
            var $ = "TooltipArrow",
                H = n.forwardRef((t, e) => {
                    let {
                        __scopeTooltip: i,
                        ...n
                    } = t, r = x(i);
                    return O($, i).isInside ? null : (0, g.jsx)(u.i3, {
                        ...r,
                        ...n,
                        ref: e
                    })
                });
            H.displayName = $;
            var z = E,
                Y = M,
                W = V,
                K = B,
                _ = I,
                X = H
        },
        20865: (t, e) => {
            e.L = {
                bit: 1
            }, e.M = {
                bit: 0
            }, e.Q = {
                bit: 3
            }, e.H = {
                bit: 2
            }, e.isValid = function(t) {
                return t && void 0 !== t.bit && t.bit >= 0 && t.bit < 4
            }, e.from = function(t, i) {
                if (e.isValid(t)) return t;
                try {
                    return function(t) {
                        if ("string" != typeof t) throw Error("Param is not a string");
                        switch (t.toLowerCase()) {
                            case "l":
                            case "low":
                                return e.L;
                            case "m":
                            case "medium":
                                return e.M;
                            case "q":
                            case "quartile":
                                return e.Q;
                            case "h":
                            case "high":
                                return e.H;
                            default:
                                throw Error("Unknown EC Level: " + t)
                        }
                    }(t)
                } catch (t) {
                    return i
                }
            }
        },
        22115: (t, e, i) => {
            let n = i(71932),
                r = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", " ", "$", "%", "*", "+", "-", ".", "/", ":"];

            function s(t) {
                this.mode = n.ALPHANUMERIC, this.data = t
            }
            s.getBitsLength = function(t) {
                return 11 * Math.floor(t / 2) + t % 2 * 6
            }, s.prototype.getLength = function() {
                return this.data.length
            }, s.prototype.getBitsLength = function() {
                return s.getBitsLength(this.data.length)
            }, s.prototype.write = function(t) {
                let e;
                for (e = 0; e + 2 <= this.data.length; e += 2) {
                    let i = 45 * r.indexOf(this.data[e]);
                    i += r.indexOf(this.data[e + 1]), t.put(i, 11)
                }
                this.data.length % 2 && t.put(r.indexOf(this.data[e]), 6)
            }, t.exports = s
        },
        25683: (t, e, i) => {
            "use strict";
            i.d(e, {
                N: () => v
            });
            var n = i(95155),
                r = i(12115),
                s = i(64710),
                o = i(99234),
                a = i(39656),
                l = i(27249);
            class u extends r.Component {
                getSnapshotBeforeUpdate(t) {
                    let e = this.props.childRef.current;
                    if (e && t.isPresent && !this.props.isPresent) {
                        let t = e.offsetParent,
                            i = t instanceof HTMLElement && t.offsetWidth || 0,
                            n = this.props.sizeRef.current;
                        n.height = e.offsetHeight || 0, n.width = e.offsetWidth || 0, n.top = e.offsetTop, n.left = e.offsetLeft, n.right = i - n.width - n.left
                    }
                    return null
                }
                componentDidUpdate() {}
                render() {
                    return this.props.children
                }
            }

            function h(t) {
                let {
                    children: e,
                    isPresent: i,
                    anchorX: s
                } = t, o = (0, r.useId)(), a = (0, r.useRef)(null), h = (0, r.useRef)({
                    width: 0,
                    height: 0,
                    top: 0,
                    left: 0,
                    right: 0
                }), {
                    nonce: d
                } = (0, r.useContext)(l.Q);
                return (0, r.useInsertionEffect)(() => {
                    let {
                        width: t,
                        height: e,
                        top: n,
                        left: r,
                        right: l
                    } = h.current;
                    if (i || !a.current || !t || !e) return;
                    a.current.dataset.motionPopId = o;
                    let u = document.createElement("style");
                    return d && (u.nonce = d), document.head.appendChild(u), u.sheet && u.sheet.insertRule('\n          [data-motion-pop-id="'.concat(o, '"] {\n            position: absolute !important;\n            width: ').concat(t, "px !important;\n            height: ").concat(e, "px !important;\n            ").concat("left" === s ? "left: ".concat(r) : "right: ".concat(l), "px !important;\n            top: ").concat(n, "px !important;\n          }\n        ")), () => {
                        document.head.removeChild(u)
                    }
                }, [i]), (0, n.jsx)(u, {
                    isPresent: i,
                    childRef: a,
                    sizeRef: h,
                    children: r.cloneElement(e, {
                        ref: a
                    })
                })
            }
            let d = t => {
                let {
                    children: e,
                    initial: i,
                    isPresent: s,
                    onExitComplete: l,
                    custom: u,
                    presenceAffectsLayout: d,
                    mode: p,
                    anchorX: f
                } = t, m = (0, o.M)(c), g = (0, r.useId)(), v = (0, r.useCallback)(t => {
                    for (let e of (m.set(t, !0), m.values()))
                        if (!e) return;
                    l && l()
                }, [m, l]), y = (0, r.useMemo)(() => ({
                    id: g,
                    initial: i,
                    isPresent: s,
                    custom: u,
                    onExitComplete: v,
                    register: t => (m.set(t, !1), () => m.delete(t))
                }), d ? [Math.random(), v] : [s, v]);
                return (0, r.useMemo)(() => {
                    m.forEach((t, e) => m.set(e, !1))
                }, [s]), r.useEffect(() => {
                    s || m.size || !l || l()
                }, [s]), "popLayout" === p && (e = (0, n.jsx)(h, {
                    isPresent: s,
                    anchorX: f,
                    children: e
                })), (0, n.jsx)(a.t.Provider, {
                    value: y,
                    children: e
                })
            };

            function c() {
                return new Map
            }
            var p = i(85087);
            let f = t => t.key || "";

            function m(t) {
                let e = [];
                return r.Children.forEach(t, t => {
                    (0, r.isValidElement)(t) && e.push(t)
                }), e
            }
            var g = i(35403);
            let v = t => {
                let {
                    children: e,
                    custom: i,
                    initial: a = !0,
                    onExitComplete: l,
                    presenceAffectsLayout: u = !0,
                    mode: h = "sync",
                    propagate: c = !1,
                    anchorX: v = "left"
                } = t, [y, x] = (0, p.xQ)(c), w = (0, r.useMemo)(() => m(e), [e]), T = c && !y ? [] : w.map(f), P = (0, r.useRef)(!0), b = (0, r.useRef)(w), E = (0, o.M)(() => new Map), [A, S] = (0, r.useState)(w), [C, M] = (0, r.useState)(w);
                (0, g.E)(() => {
                    P.current = !1, b.current = w;
                    for (let t = 0; t < C.length; t++) {
                        let e = f(C[t]);
                        T.includes(e) ? E.delete(e) : !0 !== E.get(e) && E.set(e, !1)
                    }
                }, [C, T.length, T.join("-")]);
                let R = [];
                if (w !== A) {
                    let t = [...w];
                    for (let e = 0; e < C.length; e++) {
                        let i = C[e],
                            n = f(i);
                        T.includes(n) || (t.splice(e, 0, i), R.push(i))
                    }
                    return "wait" === h && R.length && (t = R), M(m(t)), S(w), null
                }
                let {
                    forceRender: V
                } = (0, r.useContext)(s.L);
                return (0, n.jsx)(n.Fragment, {
                    children: C.map(t => {
                        let e = f(t),
                            r = (!c || !!y) && (w === C || T.includes(e));
                        return (0, n.jsx)(d, {
                            isPresent: r,
                            initial: (!P.current || !!a) && void 0,
                            custom: i,
                            presenceAffectsLayout: u,
                            mode: h,
                            onExitComplete: r ? void 0 : () => {
                                if (!E.has(e)) return;
                                E.set(e, !0);
                                let t = !0;
                                E.forEach(e => {
                                    e || (t = !1)
                                }), t && (null == V || V(), M(b.current), c && (null == x || x()), l && l())
                            },
                            anchorX: v,
                            children: t
                        }, e)
                    })
                })
            }
        },
        26734: (t, e) => {
            let i = "[0-9]+",
                n = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+",
                r = "(?:(?![A-Z0-9 $%*+\\-./:]|" + (n = n.replace(/u/g, "\\u")) + ")(?:.|[\r\n]))+";
            e.KANJI = RegExp(n, "g"), e.BYTE_KANJI = RegExp("[^A-Z0-9 $%*+\\-./:]+", "g"), e.BYTE = RegExp(r, "g"), e.NUMERIC = RegExp(i, "g"), e.ALPHANUMERIC = RegExp("[A-Z $%*+\\-./:]+", "g");
            let s = RegExp("^" + n + "$"),
                o = RegExp("^" + i + "$"),
                a = RegExp("^[A-Z0-9 $%*+\\-./:]+$");
            e.testKanji = function(t) {
                return s.test(t)
            }, e.testNumeric = function(t) {
                return o.test(t)
            }, e.testAlphanumeric = function(t) {
                return a.test(t)
            }
        },
        27249: (t, e, i) => {
            "use strict";
            i.d(e, {
                Q: () => n
            });
            let n = (0, i(12115).createContext)({
                transformPagePoint: t => t,
                isStatic: !1,
                reducedMotion: "never"
            })
        },
        28181: (t, e, i) => {
            let n = i(71932),
                r = i(53773),
                s = i(22115),
                o = i(85688),
                a = i(47873),
                l = i(26734),
                u = i(56880),
                h = i(45130);

            function d(t) {
                return unescape(encodeURIComponent(t)).length
            }

            function c(t, e, i) {
                let n;
                let r = [];
                for (; null !== (n = t.exec(i));) r.push({
                    data: n[0],
                    index: n.index,
                    mode: e,
                    length: n[0].length
                });
                return r
            }

            function p(t) {
                let e, i;
                let r = c(l.NUMERIC, n.NUMERIC, t),
                    s = c(l.ALPHANUMERIC, n.ALPHANUMERIC, t);
                return u.isKanjiModeEnabled() ? (e = c(l.BYTE, n.BYTE, t), i = c(l.KANJI, n.KANJI, t)) : (e = c(l.BYTE_KANJI, n.BYTE, t), i = []), r.concat(s, e, i).sort(function(t, e) {
                    return t.index - e.index
                }).map(function(t) {
                    return {
                        data: t.data,
                        mode: t.mode,
                        length: t.length
                    }
                })
            }

            function f(t, e) {
                switch (e) {
                    case n.NUMERIC:
                        return r.getBitsLength(t);
                    case n.ALPHANUMERIC:
                        return s.getBitsLength(t);
                    case n.KANJI:
                        return a.getBitsLength(t);
                    case n.BYTE:
                        return o.getBitsLength(t)
                }
            }

            function m(t, e) {
                let i;
                let l = n.getBestModeForData(t);
                if ((i = n.from(e, l)) !== n.BYTE && i.bit < l.bit) throw Error('"' + t + '" cannot be encoded with mode ' + n.toString(i) + ".\n Suggested mode is: " + n.toString(l));
                switch (i !== n.KANJI || u.isKanjiModeEnabled() || (i = n.BYTE), i) {
                    case n.NUMERIC:
                        return new r(t);
                    case n.ALPHANUMERIC:
                        return new s(t);
                    case n.KANJI:
                        return new a(t);
                    case n.BYTE:
                        return new o(t)
                }
            }
            e.fromArray = function(t) {
                return t.reduce(function(t, e) {
                    return "string" == typeof e ? t.push(m(e, null)) : e.data && t.push(m(e.data, e.mode)), t
                }, [])
            }, e.fromString = function(t, i) {
                let r = function(t, e) {
                        let i = {},
                            r = {
                                start: {}
                            },
                            s = ["start"];
                        for (let o = 0; o < t.length; o++) {
                            let a = t[o],
                                l = [];
                            for (let t = 0; t < a.length; t++) {
                                let u = a[t],
                                    h = "" + o + t;
                                l.push(h), i[h] = {
                                    node: u,
                                    lastCount: 0
                                }, r[h] = {};
                                for (let t = 0; t < s.length; t++) {
                                    let o = s[t];
                                    i[o] && i[o].node.mode === u.mode ? (r[o][h] = f(i[o].lastCount + u.length, u.mode) - f(i[o].lastCount, u.mode), i[o].lastCount += u.length) : (i[o] && (i[o].lastCount = u.length), r[o][h] = f(u.length, u.mode) + 4 + n.getCharCountIndicator(u.mode, e))
                                }
                            }
                            s = l
                        }
                        for (let t = 0; t < s.length; t++) r[s[t]].end = 0;
                        return {
                            map: r,
                            table: i
                        }
                    }(function(t) {
                        let e = [];
                        for (let i = 0; i < t.length; i++) {
                            let r = t[i];
                            switch (r.mode) {
                                case n.NUMERIC:
                                    e.push([r, {
                                        data: r.data,
                                        mode: n.ALPHANUMERIC,
                                        length: r.length
                                    }, {
                                        data: r.data,
                                        mode: n.BYTE,
                                        length: r.length
                                    }]);
                                    break;
                                case n.ALPHANUMERIC:
                                    e.push([r, {
                                        data: r.data,
                                        mode: n.BYTE,
                                        length: r.length
                                    }]);
                                    break;
                                case n.KANJI:
                                    e.push([r, {
                                        data: r.data,
                                        mode: n.BYTE,
                                        length: d(r.data)
                                    }]);
                                    break;
                                case n.BYTE:
                                    e.push([{
                                        data: r.data,
                                        mode: n.BYTE,
                                        length: d(r.data)
                                    }])
                            }
                        }
                        return e
                    }(p(t, u.isKanjiModeEnabled())), i),
                    s = h.find_path(r.map, "start", "end"),
                    o = [];
                for (let t = 1; t < s.length - 1; t++) o.push(r.table[s[t]].node);
                return e.fromArray(o.reduce(function(t, e) {
                    let i = t.length - 1 >= 0 ? t[t.length - 1] : null;
                    return i && i.mode === e.mode ? t[t.length - 1].data += e.data : t.push(e), t
                }, []))
            }, e.rawSplit = function(t) {
                return e.fromArray(p(t, u.isKanjiModeEnabled()))
            }
        },
        35040: (t, e) => {
            e.isValid = function(t) {
                return !isNaN(t) && t >= 1 && t <= 40
            }
        },
        35403: (t, e, i) => {
            "use strict";
            i.d(e, {
                E: () => r
            });
            var n = i(12115);
            let r = i(15687).B ? n.useLayoutEffect : n.useEffect
        },
        39656: (t, e, i) => {
            "use strict";
            i.d(e, {
                t: () => n
            });
            let n = (0, i(12115).createContext)(null)
        },
        40297: (t, e, i) => {
            "use strict";
            i.d(e, {
                Xd: () => r,
                m8: () => n
            });
            let n = "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
                r = "0x0000000000000000000000000000000000000000"
        },
        40934: (t, e, i) => {
            let n = i(62172);

            function r(t, e) {
                let i = t.a / 255,
                    n = e + '="' + t.hex + '"';
                return i < 1 ? n + " " + e + '-opacity="' + i.toFixed(2).slice(1) + '"' : n
            }

            function s(t, e, i) {
                let n = t + e;
                return void 0 !== i && (n += " " + i), n
            }
            e.render = function(t, e, i) {
                let o = n.getOptions(e),
                    a = t.modules.size,
                    l = t.modules.data,
                    u = a + 2 * o.margin,
                    h = o.color.light.a ? "<path " + r(o.color.light, "fill") + ' d="M0 0h' + u + "v" + u + 'H0z"/>' : "",
                    d = "<path " + r(o.color.dark, "stroke") + ' d="' + function(t, e, i) {
                        let n = "",
                            r = 0,
                            o = !1,
                            a = 0;
                        for (let l = 0; l < t.length; l++) {
                            let u = Math.floor(l % e),
                                h = Math.floor(l / e);
                            u || o || (o = !0), t[l] ? (a++, l > 0 && u > 0 && t[l - 1] || (n += o ? s("M", u + i, .5 + h + i) : s("m", r, 0), r = 0, o = !1), u + 1 < e && t[l + 1] || (n += s("h", a), a = 0)) : r++
                        }
                        return n
                    }(l, a, o.margin) + '"/>',
                    c = '<svg xmlns="http://www.w3.org/2000/svg" ' + (o.width ? 'width="' + o.width + '" height="' + o.width + '" ' : "") + ('viewBox="0 0 ' + u + " ") + u + '" shape-rendering="crispEdges">' + h + d + "</svg>\n";
                return "function" == typeof i && i(null, c), c
            }
        },
        45130: t => {
            "use strict";
            var e = {
                single_source_shortest_paths: function(t, i, n) {
                    var r, s, o, a, l, u, h, d = {},
                        c = {};
                    c[i] = 0;
                    var p = e.PriorityQueue.make();
                    for (p.push(i, 0); !p.empty();)
                        for (o in s = (r = p.pop()).value, a = r.cost, l = t[s] || {}) l.hasOwnProperty(o) && (u = a + l[o], h = c[o], (void 0 === c[o] || h > u) && (c[o] = u, p.push(o, u), d[o] = s));
                    if (void 0 !== n && void 0 === c[n]) throw Error(["Could not find a path from ", i, " to ", n, "."].join(""));
                    return d
                },
                extract_shortest_path_from_predecessor_list: function(t, e) {
                    for (var i = [], n = e; n;) i.push(n), t[n], n = t[n];
                    return i.reverse(), i
                },
                find_path: function(t, i, n) {
                    var r = e.single_source_shortest_paths(t, i, n);
                    return e.extract_shortest_path_from_predecessor_list(r, n)
                },
                PriorityQueue: {
                    make: function(t) {
                        var i, n = e.PriorityQueue,
                            r = {};
                        for (i in t = t || {}, n) n.hasOwnProperty(i) && (r[i] = n[i]);
                        return r.queue = [], r.sorter = t.sorter || n.default_sorter, r
                    },
                    default_sorter: function(t, e) {
                        return t.cost - e.cost
                    },
                    push: function(t, e) {
                        this.queue.push({
                            value: t,
                            cost: e
                        }), this.queue.sort(this.sorter)
                    },
                    pop: function() {
                        return this.queue.shift()
                    },
                    empty: function() {
                        return 0 === this.queue.length
                    }
                }
            };
            t.exports = e
        },
        47685: t => {
            t.exports = function() {
                return "function" == typeof Promise && Promise.prototype && Promise.prototype.then
            }
        },
        47873: (t, e, i) => {
            let n = i(71932),
                r = i(56880);

            function s(t) {
                this.mode = n.KANJI, this.data = t
            }
            s.getBitsLength = function(t) {
                return 13 * t
            }, s.prototype.getLength = function() {
                return this.data.length
            }, s.prototype.getBitsLength = function() {
                return s.getBitsLength(this.data.length)
            }, s.prototype.write = function(t) {
                let e;
                for (e = 0; e < this.data.length; e++) {
                    let i = r.toSJIS(this.data[e]);
                    if (i >= 33088 && i <= 40956) i -= 33088;
                    else if (i >= 57408 && i <= 60351) i -= 49472;
                    else throw Error("Invalid SJIS character: " + this.data[e] + "\nMake sure your charset is UTF-8");
                    i = (i >>> 8 & 255) * 192 + (255 & i), t.put(i, 13)
                }
            }, t.exports = s
        },
        48071: t => {
            function e() {
                this.buffer = [], this.length = 0
            }
            e.prototype = {
                get: function(t) {
                    let e = Math.floor(t / 8);
                    return (this.buffer[e] >>> 7 - t % 8 & 1) == 1
                },
                put: function(t, e) {
                    for (let i = 0; i < e; i++) this.putBit((t >>> e - i - 1 & 1) == 1)
                },
                getLengthInBits: function() {
                    return this.length
                },
                putBit: function(t) {
                    let e = Math.floor(this.length / 8);
                    this.buffer.length <= e && this.buffer.push(0), t && (this.buffer[e] |= 128 >>> this.length % 8), this.length++
                }
            }, t.exports = e
        },
        53773: (t, e, i) => {
            let n = i(71932);

            function r(t) {
                this.mode = n.NUMERIC, this.data = t.toString()
            }
            r.getBitsLength = function(t) {
                return 10 * Math.floor(t / 3) + (t % 3 ? t % 3 * 3 + 1 : 0)
            }, r.prototype.getLength = function() {
                return this.data.length
            }, r.prototype.getBitsLength = function() {
                return r.getBitsLength(this.data.length)
            }, r.prototype.write = function(t) {
                let e, i, n;
                for (e = 0; e + 3 <= this.data.length; e += 3) n = parseInt(this.data.substr(e, 3), 10), t.put(n, 10);
                let r = this.data.length - e;
                r > 0 && (n = parseInt(this.data.substr(e), 10), t.put(n, 3 * r + 1))
            }, t.exports = r
        },
        53972: t => {
            function e(t) {
                if (!t || t < 1) throw Error("BitMatrix size must be defined and greater than 0");
                this.size = t, this.data = new Uint8Array(t * t), this.reservedBit = new Uint8Array(t * t)
            }
            e.prototype.set = function(t, e, i, n) {
                let r = t * this.size + e;
                this.data[r] = i, n && (this.reservedBit[r] = !0)
            }, e.prototype.get = function(t, e) {
                return this.data[t * this.size + e]
            }, e.prototype.xor = function(t, e, i) {
                this.data[t * this.size + e] ^= i
            }, e.prototype.isReserved = function(t, e) {
                return this.reservedBit[t * this.size + e]
            }, t.exports = e
        },
        54557: (t, e, i) => {
            let n = i(56880),
                r = i(93684),
                s = i(20865),
                o = i(71932),
                a = i(35040),
                l = n.getBCHDigit(7973);

            function u(t, e) {
                return o.getCharCountIndicator(t, e) + 4
            }
            e.from = function(t, e) {
                return a.isValid(t) ? parseInt(t, 10) : e
            }, e.getCapacity = function(t, e, i) {
                if (!a.isValid(t)) throw Error("Invalid QR Code version");
                void 0 === i && (i = o.BYTE);
                let s = (n.getSymbolTotalCodewords(t) - r.getTotalCodewordsCount(t, e)) * 8;
                if (i === o.MIXED) return s;
                let l = s - u(i, t);
                switch (i) {
                    case o.NUMERIC:
                        return Math.floor(l / 10 * 3);
                    case o.ALPHANUMERIC:
                        return Math.floor(l / 11 * 2);
                    case o.KANJI:
                        return Math.floor(l / 13);
                    case o.BYTE:
                    default:
                        return Math.floor(l / 8)
                }
            }, e.getBestVersionForData = function(t, i) {
                let n;
                let r = s.from(i, s.M);
                if (Array.isArray(t)) {
                    if (t.length > 1) return function(t, i) {
                        for (let n = 1; n <= 40; n++)
                            if (function(t, e) {
                                    let i = 0;
                                    return t.forEach(function(t) {
                                        let n = u(t.mode, e);
                                        i += n + t.getBitsLength()
                                    }), i
                                }(t, n) <= e.getCapacity(n, i, o.MIXED)) return n
                    }(t, r);
                    if (0 === t.length) return 1;
                    n = t[0]
                } else n = t;
                return function(t, i, n) {
                    for (let r = 1; r <= 40; r++)
                        if (i <= e.getCapacity(r, n, t)) return r
                }(n.mode, n.getLength(), r)
            }, e.getEncodedBits = function(t) {
                if (!a.isValid(t) || t < 7) throw Error("Invalid QR Code version");
                let e = t << 12;
                for (; n.getBCHDigit(e) - l >= 0;) e ^= 7973 << n.getBCHDigit(e) - l;
                return t << 12 | e
            }
        },
        56880: (t, e) => {
            let i;
            let n = [0, 26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655, 733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706];
            e.getSymbolSize = function(t) {
                if (!t) throw Error('"version" cannot be null or undefined');
                if (t < 1 || t > 40) throw Error('"version" should be in range from 1 to 40');
                return 4 * t + 17
            }, e.getSymbolTotalCodewords = function(t) {
                return n[t]
            }, e.getBCHDigit = function(t) {
                let e = 0;
                for (; 0 !== t;) e++, t >>>= 1;
                return e
            }, e.setToSJISFunction = function(t) {
                if ("function" != typeof t) throw Error('"toSJISFunc" is not a valid function.');
                i = t
            }, e.isKanjiModeEnabled = function() {
                return void 0 !== i
            }, e.toSJIS = function(t) {
                return i(t)
            }
        },
        60090: (t, e, i) => {
            "use strict";
            i.d(e, {
                e: () => g
            });
            var n = i(95155),
                r = i(12115),
                s = i(7853),
                o = i(17940),
                a = i(29524),
                l = i(89703),
                u = i(2992);
            let h = (0, l.jx)(t => {
                let {
                    modalSize: e
                } = t, i = (0, s.QP)();
                return {
                    color: i.colors.primaryText,
                    background: i.colors.modalBg,
                    height: "compact" === e ? "auto" : u.gr,
                    width: "compact" === e ? u.FE : u.HC,
                    boxSizing: "border-box",
                    position: "relative",
                    lineHeight: "normal",
                    borderRadius: a.r8.xl,
                    border: "1px solid ".concat(i.colors.borderColor),
                    overflow: "hidden",
                    fontFamily: i.fontFamily,
                    "& *::selection": {
                        backgroundColor: i.colors.selectedTextBg,
                        color: i.colors.selectedTextColor
                    },
                    "& *": {
                        boxSizing: "border-box"
                    }
                }
            });
            var d = i(61294),
                c = i(21698),
                p = i(46370),
                f = i(55970),
                m = i(44925);

            function g(t) {
                var e, i, a;
                let l = (0, d.m)(t.locale || "en_US"),
                    [u, g] = (0, r.useState)("buy"),
                    v = t.theme || "dark",
                    y = (0, o.Hy)();
                (0, r.useEffect)(() => {
                    var e, i;
                    (null === (e = t.connectOptions) || void 0 === e ? void 0 : e.chain) && y.defineChains([null === (i = t.connectOptions) || void 0 === i ? void 0 : i.chain])
                }, [null === (e = t.connectOptions) || void 0 === e ? void 0 : e.chain, y]), (0, r.useEffect)(() => {
                    var e, i;
                    (null === (e = t.connectOptions) || void 0 === e ? void 0 : e.chains) && y.defineChains(null === (i = t.connectOptions) || void 0 === i ? void 0 : i.chains)
                }, [null === (i = t.connectOptions) || void 0 === i ? void 0 : i.chains, y]), (0, r.useEffect)(() => {
                    t.activeWallet && y.setActiveWallet(t.activeWallet)
                }, [t.activeWallet, y]);
                let x = null,
                    w = t.payOptions && "metadata" in t.payOptions ? t.payOptions.metadata : null;
                return x = l.data ? (0, n.jsxs)(n.Fragment, {
                    children: ["buy" === u && (0, n.jsx)(c.default, {
                        title: (null == w ? void 0 : w.name) || "Buy",
                        isEmbed: !0,
                        supportedTokens: t.supportedTokens,
                        theme: v,
                        client: t.client,
                        connectLocale: l.data,
                        hiddenWallets: t.hiddenWallets,
                        payOptions: t.payOptions || {
                            mode: "fund_wallet"
                        },
                        onDone: () => {
                            var e;
                            (null === (e = t.payOptions) || void 0 === e ? void 0 : e.mode) === "transaction" && g("execute-tx")
                        },
                        connectOptions: t.connectOptions,
                        onBack: void 0
                    }), "execute-tx" === u && (null === (a = t.payOptions) || void 0 === a ? void 0 : a.mode) === "transaction" && t.payOptions.transaction && (0, n.jsx)(p.h, {
                        tx: t.payOptions.transaction,
                        closeModal: () => {
                            g("buy")
                        },
                        onBack: () => {
                            g("buy")
                        },
                        onTxSent: e => {
                            var i, n;
                            null === (n = t.payOptions) || void 0 === n || null === (i = n.onPurchaseSuccess) || void 0 === i || i.call(n, {
                                type: "transaction",
                                chainId: e.chain.id,
                                transactionHash: e.transactionHash
                            })
                        }
                    })]
                }) : (0, n.jsx)("div", {
                    style: {
                        minHeight: "350px",
                        display: "flex",
                        justifyContent: "center",
                        alignItems: "center"
                    },
                    children: (0, n.jsx)(m.y, {
                        size: "xl",
                        color: "secondaryText"
                    })
                }), (0, n.jsx)(s.sO, {
                    theme: v,
                    children: (0, n.jsx)(h, {
                        modalSize: "compact",
                        style: t.style,
                        className: t.className,
                        children: (0, n.jsx)(f.X, {
                            children: x
                        })
                    })
                })
            }
        },
        62172: (t, e) => {
            function i(t) {
                if ("number" == typeof t && (t = t.toString()), "string" != typeof t) throw Error("Color should be defined as hex string");
                let e = t.slice().replace("#", "").split("");
                if (e.length < 3 || 5 === e.length || e.length > 8) throw Error("Invalid hex color: " + t);
                (3 === e.length || 4 === e.length) && (e = Array.prototype.concat.apply([], e.map(function(t) {
                    return [t, t]
                }))), 6 === e.length && e.push("F", "F");
                let i = parseInt(e.join(""), 16);
                return {
                    r: i >> 24 & 255,
                    g: i >> 16 & 255,
                    b: i >> 8 & 255,
                    a: 255 & i,
                    hex: "#" + e.slice(0, 6).join("")
                }
            }
            e.getOptions = function(t) {
                t || (t = {}), t.color || (t.color = {});
                let e = void 0 === t.margin || null === t.margin || t.margin < 0 ? 4 : t.margin,
                    n = t.width && t.width >= 21 ? t.width : void 0,
                    r = t.scale || 4;
                return {
                    width: n,
                    scale: n ? 4 : r,
                    margin: e,
                    color: {
                        dark: i(t.color.dark || "#000000ff"),
                        light: i(t.color.light || "#ffffffff")
                    },
                    type: t.type,
                    rendererOpts: t.rendererOpts || {}
                }
            }, e.getScale = function(t, e) {
                return e.width && e.width >= t + 2 * e.margin ? e.width / (t + 2 * e.margin) : e.scale
            }, e.getImageWidth = function(t, i) {
                let n = e.getScale(t, i);
                return Math.floor((t + 2 * i.margin) * n)
            }, e.qrToImageData = function(t, i, n) {
                let r = i.modules.size,
                    s = i.modules.data,
                    o = e.getScale(r, n),
                    a = Math.floor((r + 2 * n.margin) * o),
                    l = n.margin * o,
                    u = [n.color.light, n.color.dark];
                for (let e = 0; e < a; e++)
                    for (let i = 0; i < a; i++) {
                        let h = (e * a + i) * 4,
                            d = n.color.light;
                        e >= l && i >= l && e < a - l && i < a - l && (d = u[+!!s[Math.floor((e - l) / o) * r + Math.floor((i - l) / o)]]), t[h++] = d.r, t[h++] = d.g, t[h++] = d.b, t[h] = d.a
                    }
            }
        },
        64710: (t, e, i) => {
            "use strict";
            i.d(e, {
                L: () => n
            });
            let n = (0, i(12115).createContext)({})
        },
        69616: (t, e) => {
            e.Patterns = {
                PATTERN000: 0,
                PATTERN001: 1,
                PATTERN010: 2,
                PATTERN011: 3,
                PATTERN100: 4,
                PATTERN101: 5,
                PATTERN110: 6,
                PATTERN111: 7
            };
            let i = {
                N1: 3,
                N2: 3,
                N3: 40,
                N4: 10
            };
            e.isValid = function(t) {
                return null != t && "" !== t && !isNaN(t) && t >= 0 && t <= 7
            }, e.from = function(t) {
                return e.isValid(t) ? parseInt(t, 10) : void 0
            }, e.getPenaltyN1 = function(t) {
                let e = t.size,
                    n = 0,
                    r = 0,
                    s = 0,
                    o = null,
                    a = null;
                for (let l = 0; l < e; l++) {
                    r = s = 0, o = a = null;
                    for (let u = 0; u < e; u++) {
                        let e = t.get(l, u);
                        e === o ? r++ : (r >= 5 && (n += i.N1 + (r - 5)), o = e, r = 1), (e = t.get(u, l)) === a ? s++ : (s >= 5 && (n += i.N1 + (s - 5)), a = e, s = 1)
                    }
                    r >= 5 && (n += i.N1 + (r - 5)), s >= 5 && (n += i.N1 + (s - 5))
                }
                return n
            }, e.getPenaltyN2 = function(t) {
                let e = t.size,
                    n = 0;
                for (let i = 0; i < e - 1; i++)
                    for (let r = 0; r < e - 1; r++) {
                        let e = t.get(i, r) + t.get(i, r + 1) + t.get(i + 1, r) + t.get(i + 1, r + 1);
                        (4 === e || 0 === e) && n++
                    }
                return n * i.N2
            }, e.getPenaltyN3 = function(t) {
                let e = t.size,
                    n = 0,
                    r = 0,
                    s = 0;
                for (let i = 0; i < e; i++) {
                    r = s = 0;
                    for (let o = 0; o < e; o++) r = r << 1 & 2047 | t.get(i, o), o >= 10 && (1488 === r || 93 === r) && n++, s = s << 1 & 2047 | t.get(o, i), o >= 10 && (1488 === s || 93 === s) && n++
                }
                return n * i.N3
            }, e.getPenaltyN4 = function(t) {
                let e = 0,
                    n = t.data.length;
                for (let i = 0; i < n; i++) e += t.data[i];
                return Math.abs(Math.ceil(100 * e / n / 5) - 10) * i.N4
            }, e.applyMask = function(t, i) {
                let n = i.size;
                for (let r = 0; r < n; r++)
                    for (let s = 0; s < n; s++) i.isReserved(s, r) || i.xor(s, r, function(t, i, n) {
                        switch (t) {
                            case e.Patterns.PATTERN000:
                                return (i + n) % 2 == 0;
                            case e.Patterns.PATTERN001:
                                return i % 2 == 0;
                            case e.Patterns.PATTERN010:
                                return n % 3 == 0;
                            case e.Patterns.PATTERN011:
                                return (i + n) % 3 == 0;
                            case e.Patterns.PATTERN100:
                                return (Math.floor(i / 2) + Math.floor(n / 3)) % 2 == 0;
                            case e.Patterns.PATTERN101:
                                return i * n % 2 + i * n % 3 == 0;
                            case e.Patterns.PATTERN110:
                                return (i * n % 2 + i * n % 3) % 2 == 0;
                            case e.Patterns.PATTERN111:
                                return (i * n % 3 + (i + n) % 2) % 2 == 0;
                            default:
                                throw Error("bad maskPattern:" + t)
                        }
                    }(t, s, r))
            }, e.getBestMask = function(t, i) {
                let n = Object.keys(e.Patterns).length,
                    r = 0,
                    s = 1 / 0;
                for (let o = 0; o < n; o++) {
                    i(o), e.applyMask(o, t);
                    let n = e.getPenaltyN1(t) + e.getPenaltyN2(t) + e.getPenaltyN3(t) + e.getPenaltyN4(t);
                    e.applyMask(o, t), n < s && (s = n, r = o)
                }
                return r
            }
        },
        71932: (t, e, i) => {
            let n = i(35040),
                r = i(26734);
            e.NUMERIC = {
                id: "Numeric",
                bit: 1,
                ccBits: [10, 12, 14]
            }, e.ALPHANUMERIC = {
                id: "Alphanumeric",
                bit: 2,
                ccBits: [9, 11, 13]
            }, e.BYTE = {
                id: "Byte",
                bit: 4,
                ccBits: [8, 16, 16]
            }, e.KANJI = {
                id: "Kanji",
                bit: 8,
                ccBits: [8, 10, 12]
            }, e.MIXED = {
                bit: -1
            }, e.getCharCountIndicator = function(t, e) {
                if (!t.ccBits) throw Error("Invalid mode: " + t);
                if (!n.isValid(e)) throw Error("Invalid version: " + e);
                return e >= 1 && e < 10 ? t.ccBits[0] : e < 27 ? t.ccBits[1] : t.ccBits[2]
            }, e.getBestModeForData = function(t) {
                return r.testNumeric(t) ? e.NUMERIC : r.testAlphanumeric(t) ? e.ALPHANUMERIC : r.testKanji(t) ? e.KANJI : e.BYTE
            }, e.toString = function(t) {
                if (t && t.id) return t.id;
                throw Error("Invalid mode")
            }, e.isValid = function(t) {
                return t && t.bit && t.ccBits
            }, e.from = function(t, i) {
                if (e.isValid(t)) return t;
                try {
                    return function(t) {
                        if ("string" != typeof t) throw Error("Param is not a string");
                        switch (t.toLowerCase()) {
                            case "numeric":
                                return e.NUMERIC;
                            case "alphanumeric":
                                return e.ALPHANUMERIC;
                            case "kanji":
                                return e.KANJI;
                            case "byte":
                                return e.BYTE;
                            default:
                                throw Error("Unknown mode: " + t)
                        }
                    }(t)
                } catch (t) {
                    return i
                }
            }
        },
        73335: (t, e, i) => {
            let n = i(56880),
                r = n.getBCHDigit(1335);
            e.getEncodedBits = function(t, e) {
                let i = t.bit << 3 | e,
                    s = i << 10;
                for (; n.getBCHDigit(s) - r >= 0;) s ^= 1335 << n.getBCHDigit(s) - r;
                return (i << 10 | s) ^ 21522
            }
        },
        77245: (t, e, i) => {
            let n = i(56880),
                r = i(20865),
                s = i(48071),
                o = i(53972),
                a = i(863),
                l = i(87428),
                u = i(69616),
                h = i(93684),
                d = i(78928),
                c = i(54557),
                p = i(73335),
                f = i(71932),
                m = i(28181);

            function g(t, e, i) {
                let n, r;
                let s = t.size,
                    o = p.getEncodedBits(e, i);
                for (n = 0; n < 15; n++) r = (o >> n & 1) == 1, n < 6 ? t.set(n, 8, r, !0) : n < 8 ? t.set(n + 1, 8, r, !0) : t.set(s - 15 + n, 8, r, !0), n < 8 ? t.set(8, s - n - 1, r, !0) : n < 9 ? t.set(8, 15 - n - 1 + 1, r, !0) : t.set(8, 15 - n - 1, r, !0);
                t.set(s - 8, 8, 1, !0)
            }
            e.create = function(t, e) {
                let i, p;
                if (void 0 === t || "" === t) throw Error("No input text");
                let v = r.M;
                return void 0 !== e && (v = r.from(e.errorCorrectionLevel, r.M), i = c.from(e.version), p = u.from(e.maskPattern), e.toSJISFunc && n.setToSJISFunction(e.toSJISFunc)),
                    function(t, e, i, r) {
                        let p;
                        if (Array.isArray(t)) p = m.fromArray(t);
                        else if ("string" == typeof t) {
                            let n = e;
                            if (!n) {
                                let e = m.rawSplit(t);
                                n = c.getBestVersionForData(e, i)
                            }
                            p = m.fromString(t, n || 40)
                        } else throw Error("Invalid data");
                        let v = c.getBestVersionForData(p, i);
                        if (!v) throw Error("The amount of data is too big to be stored in a QR Code");
                        if (e) {
                            if (e < v) throw Error("\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + v + ".\n")
                        } else e = v;
                        let y = function(t, e, i) {
                                let r = new s;
                                i.forEach(function(e) {
                                    r.put(e.mode.bit, 4), r.put(e.getLength(), f.getCharCountIndicator(e.mode, t)), e.write(r)
                                });
                                let o = (n.getSymbolTotalCodewords(t) - h.getTotalCodewordsCount(t, e)) * 8;
                                for (r.getLengthInBits() + 4 <= o && r.put(0, 4); r.getLengthInBits() % 8 != 0;) r.putBit(0);
                                let a = (o - r.getLengthInBits()) / 8;
                                for (let t = 0; t < a; t++) r.put(t % 2 ? 17 : 236, 8);
                                return function(t, e, i) {
                                    let r, s;
                                    let o = n.getSymbolTotalCodewords(e),
                                        a = o - h.getTotalCodewordsCount(e, i),
                                        l = h.getBlocksCount(e, i),
                                        u = o % l,
                                        c = l - u,
                                        p = Math.floor(o / l),
                                        f = Math.floor(a / l),
                                        m = f + 1,
                                        g = p - f,
                                        v = new d(g),
                                        y = 0,
                                        x = Array(l),
                                        w = Array(l),
                                        T = 0,
                                        P = new Uint8Array(t.buffer);
                                    for (let t = 0; t < l; t++) {
                                        let e = t < c ? f : m;
                                        x[t] = P.slice(y, y + e), w[t] = v.encode(x[t]), y += e, T = Math.max(T, e)
                                    }
                                    let b = new Uint8Array(o),
                                        E = 0;
                                    for (r = 0; r < T; r++)
                                        for (s = 0; s < l; s++) r < x[s].length && (b[E++] = x[s][r]);
                                    for (r = 0; r < g; r++)
                                        for (s = 0; s < l; s++) b[E++] = w[s][r];
                                    return b
                                }(r, t, e)
                            }(e, i, p),
                            x = new o(n.getSymbolSize(e));
                        return function(t, e) {
                                let i = t.size,
                                    n = l.getPositions(e);
                                for (let e = 0; e < n.length; e++) {
                                    let r = n[e][0],
                                        s = n[e][1];
                                    for (let e = -1; e <= 7; e++)
                                        if (!(r + e <= -1) && !(i <= r + e))
                                            for (let n = -1; n <= 7; n++) s + n <= -1 || i <= s + n || (e >= 0 && e <= 6 && (0 === n || 6 === n) || n >= 0 && n <= 6 && (0 === e || 6 === e) || e >= 2 && e <= 4 && n >= 2 && n <= 4 ? t.set(r + e, s + n, !0, !0) : t.set(r + e, s + n, !1, !0))
                                }
                            }(x, e),
                            function(t) {
                                let e = t.size;
                                for (let i = 8; i < e - 8; i++) {
                                    let e = i % 2 == 0;
                                    t.set(i, 6, e, !0), t.set(6, i, e, !0)
                                }
                            }(x),
                            function(t, e) {
                                let i = a.getPositions(e);
                                for (let e = 0; e < i.length; e++) {
                                    let n = i[e][0],
                                        r = i[e][1];
                                    for (let e = -2; e <= 2; e++)
                                        for (let i = -2; i <= 2; i++) - 2 === e || 2 === e || -2 === i || 2 === i || 0 === e && 0 === i ? t.set(n + e, r + i, !0, !0) : t.set(n + e, r + i, !1, !0)
                                }
                            }(x, e), g(x, i, 0), e >= 7 && function(t, e) {
                                let i, n, r;
                                let s = t.size,
                                    o = c.getEncodedBits(e);
                                for (let e = 0; e < 18; e++) i = Math.floor(e / 3), n = e % 3 + s - 8 - 3, r = (o >> e & 1) == 1, t.set(i, n, r, !0), t.set(n, i, r, !0)
                            }(x, e),
                            function(t, e) {
                                let i = t.size,
                                    n = -1,
                                    r = i - 1,
                                    s = 7,
                                    o = 0;
                                for (let a = i - 1; a > 0; a -= 2)
                                    for (6 === a && a--;;) {
                                        for (let i = 0; i < 2; i++)
                                            if (!t.isReserved(r, a - i)) {
                                                let n = !1;
                                                o < e.length && (n = (e[o] >>> s & 1) == 1), t.set(r, a - i, n), -1 == --s && (o++, s = 7)
                                            } if ((r += n) < 0 || i <= r) {
                                            r -= n, n = -n;
                                            break
                                        }
                                    }
                            }(x, y), isNaN(r) && (r = u.getBestMask(x, g.bind(null, x, i))), u.applyMask(r, x), g(x, i, r), {
                                modules: x,
                                version: e,
                                errorCorrectionLevel: i,
                                maskPattern: r,
                                segments: p
                            }
                    }(t, i, v, p)
            }
        },
        78928: (t, e, i) => {
            let n = i(90177);

            function r(t) {
                this.genPoly = void 0, this.degree = t, this.degree && this.initialize(this.degree)
            }
            r.prototype.initialize = function(t) {
                this.degree = t, this.genPoly = n.generateECPolynomial(this.degree)
            }, r.prototype.encode = function(t) {
                if (!this.genPoly) throw Error("Encoder not initialized");
                let e = new Uint8Array(t.length + this.degree);
                e.set(t);
                let i = n.mod(e, this.genPoly),
                    r = this.degree - i.length;
                if (r > 0) {
                    let t = new Uint8Array(this.degree);
                    return t.set(i, r), t
                }
                return i
            }, t.exports = r
        },
        79995: (t, e, i) => {
            let n = i(47685),
                r = i(77245),
                s = i(16383),
                o = i(40934);

            function a(t, e, i, s, o) {
                let a = [].slice.call(arguments, 1),
                    l = a.length,
                    u = "function" == typeof a[l - 1];
                if (!u && !n()) throw Error("Callback required as last argument");
                if (u) {
                    if (l < 2) throw Error("Too few arguments provided");
                    2 === l ? (o = i, i = e, e = s = void 0) : 3 === l && (e.getContext && void 0 === o ? (o = s, s = void 0) : (o = s, s = i, i = e, e = void 0))
                } else {
                    if (l < 1) throw Error("Too few arguments provided");
                    return 1 === l ? (i = e, e = s = void 0) : 2 !== l || e.getContext || (s = i, i = e, e = void 0), new Promise(function(n, o) {
                        try {
                            let o = r.create(i, s);
                            n(t(o, e, s))
                        } catch (t) {
                            o(t)
                        }
                    })
                }
                try {
                    let n = r.create(i, s);
                    o(null, t(n, e, s))
                } catch (t) {
                    o(t)
                }
            }
            e.create = r.create, e.toCanvas = a.bind(null, s.render), e.toDataURL = a.bind(null, s.renderToDataURL), e.toString = a.bind(null, function(t, e, i) {
                return o.render(t, i)
            })
        },
        85087: (t, e, i) => {
            "use strict";
            i.d(e, {
                xQ: () => s
            });
            var n = i(12115),
                r = i(39656);

            function s(t = !0) {
                let e = (0, n.useContext)(r.t);
                if (null === e) return [!0, null];
                let {
                    isPresent: i,
                    onExitComplete: o,
                    register: a
                } = e, l = (0, n.useId)();
                (0, n.useEffect)(() => {
                    if (t) return a(l)
                }, [t]);
                let u = (0, n.useCallback)(() => t && o && o(l), [l, o, t]);
                return !i && o ? [!1, u] : [!0]
            }
        },
        85688: (t, e, i) => {
            let n = i(71932);

            function r(t) {
                this.mode = n.BYTE, "string" == typeof t ? this.data = new TextEncoder().encode(t) : this.data = new Uint8Array(t)
            }
            r.getBitsLength = function(t) {
                return 8 * t
            }, r.prototype.getLength = function() {
                return this.data.length
            }, r.prototype.getBitsLength = function() {
                return r.getBitsLength(this.data.length)
            }, r.prototype.write = function(t) {
                for (let e = 0, i = this.data.length; e < i; e++) t.put(this.data[e], 8)
            }, t.exports = r
        },
        87428: (t, e, i) => {
            let n = i(56880).getSymbolSize;
            e.getPositions = function(t) {
                let e = n(t);
                return [
                    [0, 0],
                    [e - 7, 0],
                    [0, e - 7]
                ]
            }
        },
        90177: (t, e, i) => {
            let n = i(3455);
            e.mul = function(t, e) {
                let i = new Uint8Array(t.length + e.length - 1);
                for (let r = 0; r < t.length; r++)
                    for (let s = 0; s < e.length; s++) i[r + s] ^= n.mul(t[r], e[s]);
                return i
            }, e.mod = function(t, e) {
                let i = new Uint8Array(t);
                for (; i.length - e.length >= 0;) {
                    let t = i[0];
                    for (let r = 0; r < e.length; r++) i[r] ^= n.mul(e[r], t);
                    let r = 0;
                    for (; r < i.length && 0 === i[r];) r++;
                    i = i.slice(r)
                }
                return i
            }, e.generateECPolynomial = function(t) {
                let i = new Uint8Array([1]);
                for (let r = 0; r < t; r++) i = e.mul(i, new Uint8Array([1, n.exp(r)]));
                return i
            }
        },
        93684: (t, e, i) => {
            let n = i(20865),
                r = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 4, 1, 2, 4, 4, 2, 4, 4, 4, 2, 4, 6, 5, 2, 4, 6, 6, 2, 5, 8, 8, 4, 5, 8, 8, 4, 5, 8, 11, 4, 8, 10, 11, 4, 9, 12, 16, 4, 9, 16, 16, 6, 10, 12, 18, 6, 10, 17, 16, 6, 11, 16, 19, 6, 13, 18, 21, 7, 14, 21, 25, 8, 16, 20, 25, 8, 17, 23, 25, 9, 17, 23, 34, 9, 18, 25, 30, 10, 20, 27, 32, 12, 21, 29, 35, 12, 23, 34, 37, 12, 25, 34, 40, 13, 26, 35, 42, 14, 28, 38, 45, 15, 29, 40, 48, 16, 31, 43, 51, 17, 33, 45, 54, 18, 35, 48, 57, 19, 37, 51, 60, 19, 38, 53, 63, 20, 40, 56, 66, 21, 43, 59, 70, 22, 45, 62, 74, 24, 47, 65, 77, 25, 49, 68, 81],
                s = [7, 10, 13, 17, 10, 16, 22, 28, 15, 26, 36, 44, 20, 36, 52, 64, 26, 48, 72, 88, 36, 64, 96, 112, 40, 72, 108, 130, 48, 88, 132, 156, 60, 110, 160, 192, 72, 130, 192, 224, 80, 150, 224, 264, 96, 176, 260, 308, 104, 198, 288, 352, 120, 216, 320, 384, 132, 240, 360, 432, 144, 280, 408, 480, 168, 308, 448, 532, 180, 338, 504, 588, 196, 364, 546, 650, 224, 416, 600, 700, 224, 442, 644, 750, 252, 476, 690, 816, 270, 504, 750, 900, 300, 560, 810, 960, 312, 588, 870, 1050, 336, 644, 952, 1110, 360, 700, 1020, 1200, 390, 728, 1050, 1260, 420, 784, 1140, 1350, 450, 812, 1200, 1440, 480, 868, 1290, 1530, 510, 924, 1350, 1620, 540, 980, 1440, 1710, 570, 1036, 1530, 1800, 570, 1064, 1590, 1890, 600, 1120, 1680, 1980, 630, 1204, 1770, 2100, 660, 1260, 1860, 2220, 720, 1316, 1950, 2310, 750, 1372, 2040, 2430];
            e.getBlocksCount = function(t, e) {
                switch (e) {
                    case n.L:
                        return r[(t - 1) * 4 + 0];
                    case n.M:
                        return r[(t - 1) * 4 + 1];
                    case n.Q:
                        return r[(t - 1) * 4 + 2];
                    case n.H:
                        return r[(t - 1) * 4 + 3];
                    default:
                        return
                }
            }, e.getTotalCodewordsCount = function(t, e) {
                switch (e) {
                    case n.L:
                        return s[(t - 1) * 4 + 0];
                    case n.M:
                        return s[(t - 1) * 4 + 1];
                    case n.Q:
                        return s[(t - 1) * 4 + 2];
                    case n.H:
                        return s[(t - 1) * 4 + 3];
                    default:
                        return
                }
            }
        },
        99234: (t, e, i) => {
            "use strict";
            i.d(e, {
                M: () => r
            });
            var n = i(12115);

            function r(t) {
                let e = (0, n.useRef)(null);
                return null === e.current && (e.current = t()), e.current
            }
        }
    }
]);